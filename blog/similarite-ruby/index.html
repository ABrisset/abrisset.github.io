<!DOCTYPE html><html lang=fr><head><meta charset=utf-8 /><meta content="width=device-width,initial-scale=1" name=viewport /><title>Détection du contenu dupliqué avec Ruby et le Cosinus de Salton &bull; Antoine Brisset</title><meta content="Découvrez comment calculer un score de proximité sémantique (cosinus de Salton) entre les pages de votre site, grâce à plusieurs gems Ruby bien pratiques !" name=description /><meta content="index,follow" name=robots /><meta content=R7aPiADkUTnBNzbTvsqutfN3_gewIxUFwJpKYyc-hBQ name=google-site-verification /><link href="/apple-touch-icon.png" rel=apple-touch-icon sizes=57x57 /><link href="/apple-touch-icon-57x57-precomposed.png" rel=apple-touch-icon sizes=57x57 /><link href="/apple-touch-icon-60x60-precomposed.png" rel=apple-touch-icon sizes=60x60 /><link href="/apple-touch-icon-72x72-precomposed.png" rel=apple-touch-icon sizes=72x72 /><link href="/apple-touch-icon-76x76-precomposed.png" rel=apple-touch-icon sizes=76x76 /><link href="/apple-touch-icon-114x114-precomposed.png" rel=apple-touch-icon sizes=114x114 /><link href="/apple-touch-icon-120x120-precomposed.png" rel=apple-touch-icon sizes=120x120 /><link href="/apple-touch-icon-144x144-precomposed.png" rel=apple-touch-icon sizes=144x144 /><link href="/apple-touch-icon-152x152-precomposed.png" rel=apple-touch-icon sizes=152x152 /><link href="/favicon-196x196.png" rel=icon sizes=196x196 type="image/png"/><link href="/favicon-160x160.png" rel=icon sizes=160x160 type="image/png"/><link href="/favicon-96x96.png" rel=icon sizes=96x96 type="image/png"/><link href="/favicon-32x32.png" rel=icon sizes=32x32 type="image/png"/><link href="/favicon-16x16.png" rel=icon sizes=16x16 type="image/png"/><meta content="#f5f5f5" name=msapplication-TileColor /><meta content="/mstile-144x144.png" name=msapplication-TileImage /><link href="/stylesheets/application.css" rel=stylesheet /><link href="//fonts.googleapis.com/css?family=Open+Sans:400,300,600,700,800" rel=stylesheet /><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel=stylesheet /><style>.header{background-image: url('/images/backgrounds/small/semantic.jpg');}
    @media screen and (min-width: 25em){.header{background-image: url('/images/backgrounds/medium/semantic.jpg');}}
    @media screen and (min-width: 50em){.header{background-image: url('/images/backgrounds/semantic.jpg');}}</style><script src="/javascripts/all.js"></script></head><body class="blog blog_similarite-ruby blog_similarite-ruby_index"> <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-WW7MSH" height=0 width=0 style="display:none;visibility:hidden"></iframe></noscript> <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-NKG6T7');</script> <div class=wrapper><nav role=navigation><div class=fat-nav><div class=fat-nav__wrapper><ul><li><a href="/">Accueil</a></li><li><a href="/blog/">Blog SEO</a></li><li><a href="/#contact">Contact</a></li></ul></div></div></nav></div><div role=main></div><div class=header><div class=wrapper><h1 class=header__title>Calcul de similarité avec Ruby</h1><p class=header__category><i class="fa fa-tag"></i> <em>Sémantique</em></p></div></div><div class="section section__content--large"><div class=wrapper><article class=blog__article><p class=blog__breadcrumb><a href="/blog/">Blog SEO</a> / <a href="/blog/categories/semantique/">Sémantique</a></p><p class=blog__date>Publié le 11 Oct 2015</p><p class=blog__chapo>Les solutions logicielles ou saas permettant de détecter le contenu dupliqué sur un site web sont, soit un peu trop opaques, soit un peu trop onéreuses à mon goût. Je vous présente donc ici un script rudimentaire, permettant à la fois, de crawler un site web en aspirant son contenu page à page, et de calculer la similarité de chacune des pages entre elles, en utilisant le tf-idf et le cosinus de Salton.</p><p>Le script est disponible sur <a href="https://github.com/ABrisset/dc_checker/">Github</a>. En bonus, vous y trouverez également une méthode permettant de calculer l&#39;indice de Jaccard. Côté performance, il y a très certainement des choses à revoir, notamment au niveau des calculs, très coûteux, et des requêtes MySql, non optimisées. Néanmoins, pour un petit site web, il fera très bien l&#39;affaire.</p> <h2>Crawler un site web : la gem Anemone</h2> <p>Pour crawler un site et répertorier l&#39;ensemble de ses pages, il existe une gem Ruby très pratique : <a href="https://github.com/chriskite/anemone">Anemone</a>. Je vous invite à jeter un coup d&#39;oeil à la documentation, vous verrez que les possibilités qu&#39;elle offre sont très nombreuses. Ici, je crée simplement une nouvelle instance d&#39;Anemone, en lui passant en paramètre mon URL de départ, et en lui donnant l&#39;instruction de ne suivre qu&#39;un &ldquo;niveau&rdquo; de redirection.</p> <div class=highlight><pre class="highlight ruby"><code><span class="no">Anemone</span><span class="p">.</span><span class="nf">crawl</span><span class="p">(</span><span class="n">root_url</span><span class="p">,</span> <span class="ss">:redirect_limit</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">anemone</span><span class="o">|</span>
  <span class="n">skipped_links</span> <span class="o">=</span> <span class="sr">%r{%23.*|</span><span class="se">\#</span><span class="sr">.*|.*</span><span class="se">\.</span><span class="sr">(pdf|jpg|jpeg|png|gif)}</span>
  <span class="n">anemone</span><span class="p">.</span><span class="nf">skip_links_like</span><span class="p">(</span><span class="n">skipped_links</span><span class="p">)</span>
  <span class="n">anemone</span><span class="p">.</span><span class="nf">on_every_page</span> <span class="k">do</span> <span class="o">|</span><span class="n">page</span><span class="o">|</span>
    <span class="c1"># Catch absolute URL and print it from terminal</span>
    <span class="n">absolute_url</span> <span class="o">=</span> <span class="no">URI</span><span class="p">.</span><span class="nf">decode</span><span class="p">(</span><span class="n">page</span><span class="p">.</span><span class="nf">url</span><span class="p">.</span><span class="nf">to_s</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="n">absolute_url</span>
</code></pre></div> <p>Pour éviter de suivre des liens images ou des liens vers des ancres internes, j&#39;utilise la méthode <code>skip_links_like</code>, en lui passant en paramètre l&#39;expression régulière adaptée.</p> <h2>Extraire le contenu d&#39;une page : le framework Treat</h2> <p>S&#39;il existe de très bons outils avec Python pour le traitement automatique du langage naturel (cf <a href="http://www.nltk.org/">NLKT</a>), peu de librairies aussi abouties sont disponibles avec Ruby. Néanmoins, en fouillant un peu, je suis tombé sur <a href="https://github.com/louismullie/treat/wiki/Manual">Treat</a>, qui permet de parser un texte, de le découper en entités logiques (titre, section, paragraphe, phrases), de catégoriser les mots, etc. Bref, plutôt complet.</p> <p>Revenons-en à notre script. Maintenant qu&#39;on a récupéré notre page web avec Anemone, on va utiliser les méthodes disponibles dans la classe <code>Page</code> pour récupérer uniquement le contenu texte de la page. Retirons donc les commentaires, les balises script, noscript et style, supprimons toutes les balises, décodons les éventuelles entités HTML et modifions la casse (minuscule).</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">get_content_of</span><span class="p">(</span><span class="n">page</span><span class="p">)</span>
  <span class="n">page</span><span class="p">.</span><span class="nf">doc</span>
      <span class="p">.</span><span class="nf">xpath</span><span class="p">(</span><span class="s1">'//comment()'</span><span class="p">)</span>
      <span class="p">.</span><span class="nf">remove</span>
  <span class="n">page</span><span class="p">.</span><span class="nf">doc</span>
      <span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="s1">'body'</span><span class="p">)</span>
      <span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="s1">'//script|//noscript|//style'</span><span class="p">)</span>
      <span class="p">.</span><span class="nf">remove</span>
  <span class="no">HTMLEntities</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">decode</span><span class="p">(</span><span class="n">page</span><span class="p">.</span><span class="nf">doc</span>
                              <span class="p">.</span><span class="nf">to_html</span>
                              <span class="p">.</span><span class="nf">gsub</span><span class="p">(</span><span class="sr">/&lt;[^&gt;]+&gt;/</span><span class="p">,</span> <span class="s2">"</span><span class="se">\s</span><span class="s2">"</span><span class="p">)</span>
                              <span class="p">.</span><span class="nf">downcase</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div> <p>Le contenu est maintenant normalisé. On va ensuite utiliser Treat pour isoler les mots de notre page. Découpons tout d&#39;abord le contenu en tokens, puis débarrassons-nous des signes de ponctuation et des valeurs numériques via la méthode <code>words</code>. Le tout sera stocké dans un array.</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">get_words_of_document</span>
  <span class="vi">@document</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="ss">:chunk</span><span class="p">,</span> <span class="ss">:segment</span><span class="p">,</span> <span class="ss">:tokenize</span><span class="p">)</span>
  <span class="vi">@document</span><span class="p">.</span><span class="nf">tokens</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">words</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">w</span><span class="o">|</span>
      <span class="vi">@page_content</span> <span class="o">&lt;&lt;</span> <span class="n">w</span><span class="p">.</span><span class="nf">to_s</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="vi">@page_content</span><span class="p">.</span><span class="nf">flatten</span>
<span class="k">end</span>
</code></pre></div> <p>Pour rendre l&#39;analyse plus pertinente, on élimine les stop words et on transforme les caractères accentués en caractères non-accentués (voir le détail des méthodes dans le dossier <code>/lib/</code>).</p> <div class=highlight><pre class="highlight ruby"><code><span class="n">words</span> <span class="o">=</span> <span class="n">analyzer</span><span class="p">.</span><span class="nf">get_words_of_document</span>
<span class="n">words</span> <span class="o">=</span> <span class="n">analyzer</span><span class="p">.</span><span class="nf">remove_stop_words_from</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">stop_words</span><span class="p">)</span>
<span class="n">words</span> <span class="o">=</span> <span class="n">analyzer</span><span class="p">.</span><span class="nf">remove_accents_from</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
</code></pre></div> <p>Il n&#39;y a plus qu&#39;à stocker le couple URL &lt;-&gt; contenu en base, dans la table <code>pages</code>.</p> <h2>Calculer la proximité sémantique entre deux pages : la gem Similarity</h2> <p>Pour le calcul du cosinus de Salton, utilisons la gem <a href="https://github.com/bbcrd/Similarity">Similarity</a>. Au préalable, on aura pris soin de créer une table matrice en base de données avec :</p> <p>URL A =&gt; URL A <br> URL A =&gt; URL B <br> URL A =&gt; URL C <br> URL A =&gt; URL D <br> URL B =&gt; URL A <br> URL B =&gt; URL B <br> etc.</p> <p>La méthode <a href="http://ruby-doc.org/core-1.9.3/Array.html#method-i-product"><code>product</code></a> tombe à point nommé pour effectuer cette tâche.</p> <p>[UPDATE] : j&#39;ai limité le volume de couples de pages à comparer entre elles en éliminant les doublons Par exemple les couples A =&gt; B et B =&gt; A sont des doublons, de même que A =&gt; A ou B =&gt; B qui ne doivent pas être comparés entre eux.</p> <div class=highlight><pre class="highlight ruby"><code><span class="c1">## Fill similarity table</span>
<span class="n">pages_a</span> <span class="o">=</span> <span class="vg">$connection</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="s2">"SELECT absolute_url FROM pages"</span><span class="p">)</span>
                     <span class="p">.</span><span class="nf">map</span><span class="p">{</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span> <span class="n">row</span><span class="p">[</span><span class="s1">'absolute_url'</span><span class="p">]</span> <span class="p">}</span>
<span class="n">pages_b</span> <span class="o">=</span> <span class="n">pages_a</span><span class="p">.</span><span class="nf">dup</span>

<span class="n">pages_a</span><span class="p">.</span><span class="nf">product</span><span class="p">(</span><span class="n">pages_b</span><span class="p">)</span>
       <span class="p">.</span><span class="nf">map</span><span class="p">{</span> <span class="o">|</span><span class="n">arr</span><span class="o">|</span> <span class="n">arr</span><span class="p">.</span><span class="nf">sort</span> <span class="p">}</span>
       <span class="p">.</span><span class="nf">uniq</span>
       <span class="p">.</span><span class="nf">delete_if</span><span class="p">{</span> <span class="o">|</span><span class="n">arr</span><span class="o">|</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">}</span>
       <span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">line</span><span class="o">|</span>
          <span class="n">url_a</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="n">url_b</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
          <span class="vg">$connection</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="s2">"INSERT INTO
            similarity(
              url_a,
              url_b
            )
            VALUES(
              '</span><span class="si">#{</span><span class="n">url_a</span><span class="si">}</span><span class="s2">',
              '</span><span class="si">#{</span><span class="n">url_b</span><span class="si">}</span><span class="s2">'
            )"</span>
          <span class="p">)</span>
        <span class="k">end</span>
</code></pre></div> <p>Etape finale : le calcul.</p> <p>Pour former le corpus, on instancie un nouveau document pour chaque URL en base, qu&#39;on ajoute à notre corpus. Pour identifier chaque document, mettons à jour la table <code>pages</code>. Cela nous permettra par la suite de disposer d&#39;un identifiant unique permettant de connaître quelles sont les URL comparées entre elles.</p> <div class=highlight><pre class="highlight ruby"><code><span class="c1">## Compute salton cosine</span>
<span class="n">corpus</span>        <span class="o">=</span> <span class="no">Corpus</span><span class="p">.</span><span class="nf">new</span>
<span class="n">array_of_docs</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span>
<span class="n">pages</span>         <span class="o">=</span> <span class="vg">$connection</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="s2">"SELECT absolute_url,content FROM pages"</span><span class="p">)</span>
<span class="n">pages</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span>
  <span class="n">absolute_url</span>  <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">'absolute_url'</span><span class="p">]</span>
  <span class="n">content</span>       <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">'content'</span><span class="p">]</span>
  <span class="n">document</span>      <span class="o">=</span> <span class="no">Document</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:content</span> <span class="o">=&gt;</span> <span class="n">content</span><span class="p">)</span>
  <span class="n">corpus</span>        <span class="o">&lt;&lt;</span> <span class="n">document</span>
  <span class="n">array_of_docs</span> <span class="o">&lt;&lt;</span> <span class="n">document</span>
  <span class="n">cosine_id</span> <span class="o">=</span> <span class="n">document</span><span class="p">.</span><span class="nf">id</span>
  <span class="vg">$connection</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="s2">"UPDATE pages
                     SET cosine_id      = '</span><span class="si">#{</span><span class="n">cosine_id</span><span class="si">}</span><span class="s2">'
                     WHERE absolute_url = '</span><span class="si">#{</span><span class="n">absolute_url</span><span class="si">}</span><span class="s2">'"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div> <p>Passons alors au calcul de la similarité. Chaque objet <code>document</code> ayant été au préalable stocké dans un array, il suffit de boucler sur chacun de ces objets et d&#39;utiliser la méthode <code>similar_documents</code>. Grâce à la correspondance entre l&#39;URL et l&#39;identifiant du document, on peut mettre à jour la table <code>similarity</code> avec les valeurs du cosinus de salton pour chaque couple d&#39;URL.</p> <div class=highlight><pre class="highlight ruby"><code><span class="n">array_of_docs</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">doc</span><span class="o">|</span>
  <span class="n">corpus</span><span class="p">.</span><span class="nf">similar_documents</span><span class="p">(</span><span class="n">doc</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">d</span><span class="p">,</span> <span class="n">similarity</span><span class="o">|</span>
    <span class="n">doc_a</span> <span class="o">=</span> <span class="n">doc</span><span class="p">.</span><span class="nf">id</span>
    <span class="n">doc_b</span> <span class="o">=</span> <span class="n">d</span><span class="p">.</span><span class="nf">id</span>
    <span class="vg">$connection</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="s2">"UPDATE similarity
                       SET salton_cosine = '</span><span class="si">#{</span><span class="n">similarity</span><span class="si">}</span><span class="s2">'
                       WHERE url_a =
                        (
                          SELECT absolute_url
                          FROM pages
                          WHERE cosine_id = '</span><span class="si">#{</span><span class="n">doc_a</span><span class="si">}</span><span class="s2">'
                        )
                       AND url_b =
                        (
                          SELECT absolute_url
                          FROM pages
                          WHERE cosine_id = '</span><span class="si">#{</span><span class="n">doc_b</span><span class="si">}</span><span class="s2">'
                        )
                      "</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div> <p>Si vous souhaitez avoir le détail du script, tout est <a href="https://github.com/ABrisset/dc_checker/">ici</a>, vous n&#39;avez qu&#39;à cloner le repo.</p> <div class=highlight><pre class="highlight console"><code><span class="gp">$</span> ~/Workspace/ git clone https://github.com/ABrisset/dc_checker.git
</code></pre></div> <h2>Mise en pratique</h2> <p>Lançons le script et analysons les données pour mon site www.antoine-brisset.com.</p> <div class=highlight><pre class="highlight console"><code><span class="gp">$</span> ~/Workspace/dc_checker/ ./checker.rb http://www.antoine-brisset.com abrisset
</code></pre></div> <p>Voici quelques résultats significatifs :</p> <table><thead> <tr> <th>URL A&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</th> <th>URL B&mdash;&mdash;&mdash;</th> <th>Salton &mdash;</th> </tr> </thead><tbody> <tr> <td>/blog/categories/scripts-seo/</td> <td>/blog</td> <td>0.530091</td> </tr> <tr> <td>/blog/categories/seo-on-site/</td> <td>/blog</td> <td>0.724747</td> </tr> </tbody></table> <p><br/> Comme on peut le voir ci-dessus, mes pages catégories sont en concurrence directe avec la page racine du blog. Si je veux que mes pages catégories aient une chance de se positionner, j&#39;aurai donc tout intérêt à ajouter &ndash; a minima &ndash; un texte d&#39;introduction pour chacune des pages catégories.</p> <p>Nous pouvons également, à partir de ces données, s&#39;amuser à catégoriser les différentes URL, de manière à analyser les typologies de page qui ont une similarité forte. Mettons à jour la table similarity.</p> <div class=highlight><pre class="highlight plaintext"><code>ALTER TABLE similarity
ADD category VARCHAR(255)
</code></pre></div><div class=highlight><pre class="highlight plaintext"><code>UPDATE similarity
SET category = (CASE
                WHEN url_a REGEXP '^.*categories.*$' THEN 'Page catégorie'
                WHEN url_a = 'http://www.antoine-brisset.com/' THEN 'Page d\'accueil'
                WHEN url_a = 'http://www.antoine-brisset.com/blog/' THEN 'Page blog'
                ELSE 'Page article'
                END)
</code></pre></div> <p>Hop, on calcule une moyenne du cosinus par typologie de page.</p> <div class=highlight><pre class="highlight plaintext"><code>SELECT category,AVG(salton_cosine)
FROM similarity
GROUP BY category
</code></pre></div> <p>Sans surprise, ce sont la page blog et les pages catégories qui ont l&#39;indice de similiarité &ldquo;moyen&rdquo; le plus important. Logique, puisque la page blog reprend un extrait de chaque article, et que les pages catégories ne sont qu&#39;une sélection des extraits d&#39;articles déjà présents sur la page blog.</p> <p><img src="/images/posts/excel.png" title=salton alt=salton /></p> <p>Voilà un exemple assez simple et pragmatique de détection du contenu dupliqué sur un site. Qu&#39;en pensez-vous ? Est-ce selon une méthode fiable ?</p> <div id=disqus_thread></div> <script>
//<![CDATA[
                  var disqus_shortname = 'blogantoinebrisset';
          
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
//]]>
</script> <noscript>Please enable JavaScript to view the <a href='http://disqus.com/?ref_noscript'>comments powered by Disqus.</a></noscript> <a href='http://disqus.com' class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a> </article></div></div><footer class=footer><div role=content-info><ul class=footer__content><li class=footer__content__item><i class="fa fa-home"></i> Marquette-lez-Lille</li><li class=footer__content__item><i class="fa fa-phone"></i> 06 12 71 82 78</li><li class=footer__content__item><i class="fa fa-envelope"></i> <a href="#email-protection-pbagnpg@nagbvar-oevffrg.pbz">contact@antoine-brisset.com</a> </li></ul><ul class=footer__content--social><li class=footer__content__item--social><a href="https://twitter.com/abrisset"><i class='fa fa-twitter footer__icon'></i></a></li><li class=footer__content__item--social><a href="https://github.com/ABrisset"><i class='fa fa-github footer__icon'></i></a></li><li class=footer__content__item--social><a href="http://plus.google.com/112811217796192792405?rel=author"><i class='fa fa-google-plus footer__icon'></i></a></li></ul><div class=footer__copyright> &copy; 2019 - <a href="/">Antoine Brisset</a></div></div></footer><script type="text/javascript">!function(){try{var a,b,c,d,g=document.getElementsByTagName("a");for(c=0;g.length-c;c++)try{b=g[c].getAttribute("href"),b&&b.indexOf("#email-protection-")>-1&&b.length>19&&(a="",d=19+b.indexOf("#email-protection-"),b.length>d&&(a=b.substr(18).replace(/[a-zA-Z]/g,function(a){return String.fromCharCode(("Z">=a?90:122)>=(a=a.charCodeAt(0)+13)?a:a-26)})),g[c].setAttribute("href","mailto:"+a))}catch(h){}}catch(h){}}();</script>
</body></html>