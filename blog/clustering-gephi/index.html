<!DOCTYPE html><html lang=fr><head><meta charset=utf-8 /><meta content="width=device-width,initial-scale=1" name=viewport /><title>Cluster de mots-clés : utiliser le coefficient de Dice & Gephi &bull; Antoine Brisset</title><meta content="Découvrez comment utiliser Gephi pour cartographier un univers sémantique. Quelques lignes de code, un peu de tuning dans le logiciel et le tour est joué !" name=description /><meta content="index,follow" name=robots /><meta content=R7aPiADkUTnBNzbTvsqutfN3_gewIxUFwJpKYyc-hBQ name=google-site-verification /><link href="/apple-touch-icon.png" rel=apple-touch-icon sizes=57x57 /><link href="/apple-touch-icon-57x57-precomposed.png" rel=apple-touch-icon sizes=57x57 /><link href="/apple-touch-icon-60x60-precomposed.png" rel=apple-touch-icon sizes=60x60 /><link href="/apple-touch-icon-72x72-precomposed.png" rel=apple-touch-icon sizes=72x72 /><link href="/apple-touch-icon-76x76-precomposed.png" rel=apple-touch-icon sizes=76x76 /><link href="/apple-touch-icon-114x114-precomposed.png" rel=apple-touch-icon sizes=114x114 /><link href="/apple-touch-icon-120x120-precomposed.png" rel=apple-touch-icon sizes=120x120 /><link href="/apple-touch-icon-144x144-precomposed.png" rel=apple-touch-icon sizes=144x144 /><link href="/apple-touch-icon-152x152-precomposed.png" rel=apple-touch-icon sizes=152x152 /><link href="/favicon-196x196.png" rel=icon sizes=196x196 type="image/png"/><link href="/favicon-160x160.png" rel=icon sizes=160x160 type="image/png"/><link href="/favicon-96x96.png" rel=icon sizes=96x96 type="image/png"/><link href="/favicon-32x32.png" rel=icon sizes=32x32 type="image/png"/><link href="/favicon-16x16.png" rel=icon sizes=16x16 type="image/png"/><meta content="#f5f5f5" name=msapplication-TileColor /><meta content="/mstile-144x144.png" name=msapplication-TileImage /><link href="/stylesheets/application.css" rel=stylesheet /><link href="//fonts.googleapis.com/css?family=Open+Sans:400,300,600,700,800" rel=stylesheet /><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel=stylesheet /><style>.header{background-image: url('/images/backgrounds/small/semantic.jpg');}
    @media screen and (min-width: 25em){.header{background-image: url('/images/backgrounds/medium/semantic.jpg');}}
    @media screen and (min-width: 50em){.header{background-image: url('/images/backgrounds/semantic.jpg');}}</style><script src="/javascripts/all.js"></script></head><body class="blog blog_clustering-gephi blog_clustering-gephi_index"> <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-WW7MSH" height=0 width=0 style="display:none;visibility:hidden"></iframe></noscript> <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-NKG6T7');</script> <div class=wrapper><nav role=navigation><div class=fat-nav><div class=fat-nav__wrapper><ul><li><a href="/">Accueil</a></li><li><a href="/blog/">Blog SEO</a></li><li><a href="/#contact">Contact</a></li></ul></div></div></nav></div><div role=main></div><div class=header><div class=wrapper><h1 class=header__title>Clustering de mots-clés : un exemple avec Gephi</h1><p class=header__category><i class="fa fa-tag"></i> <em>Sémantique</em></p></div></div><div class="section section__content--large"><div class=wrapper><article class=blog__article><p class=blog__breadcrumb><a href="/blog/">Blog SEO</a> / <a href="/blog/categories/semantique/">Sémantique</a></p><p class=blog__date>Publié le 27 Sep 2016</p><p class=blog__chapo>La notion de clusterisation est à nouveau abordée sur le blog, mais sous un autre angle. J'ai en effet décidé d'explorer les fonctionnalités de Gephi pour générer la cartographie d'un univers sémantique. L'objectif est de visualiser à la fois l'intérêt d'un mot-clé (volume de recherche) et la façon dont il est connecté aux autres mots-clés (similarité sémantique)</p><p><a href="http://www.antoine-brisset.com/blog/clustering-ruby-k-means/">Dans le billet précédent</a>, j&#39;ai présenté une méthode s&#39;appuyant sur l&#39;algorithme K-Means pour partitionner un corpus de mots-clés. Bien que très simple d&#39;accès, cette méthode présente l&#39;inconvénient de devoir connaître à l&#39;avance le nombre de clusters que l&#39;on souhaite créer. Pas top.</p> <p>J&#39;ai donc poursuivi mes recherches : j&#39;ai tout d&#39;abord fait l&#39;acquisition de l&#39;ouvrage de Massih-Reza Amini et Éric Gaussuier, <a href="https://www.amazon.fr/Recherche-dinformation-Applications-algorithmes-d%C3%A9cisionnel/dp/2212135327/?tag=antoine-brisset-21">Recherche d&#39;information - Applications, modèles et algorithmes. Fouille de données, décisionnel et big data</a> qui consacre un chapitre très intéressant au partitionnemet de données, et en parallèle, je me suis intéressé de plus près à Gephi. J&#39;en ai ressorti une méthodologie concrète de visualisation d&#39;un ensemble de mots-clés, qui s&#39;appuie sur le <em>coefficient de Dice</em>, ainsi que sur Gephi et ses algorithmes de clustering embarqués.</p> <h2>1ère étape : récupérer les mots-clés et leur volume de recherche</h2> <p>La première étape va consister, bien entendu, à récupérer le maximum de mots-clés dans la thématique que vous souhaitez étudier. Pour cela, je ne rentre pas dans le détail, utilisez Keywords Planner, SemRush ou tout autre outil qui pourra vous donner une correspondance entre un mot-clé et un volume de recherche mensuel.</p> <p>Formattez votre fichier de la façon suivante : une 1ère colonne intitulée &ldquo;Id&rdquo;, une 2ème colonne intitulée &ldquo;Label&rdquo; et une dernière colonne intitulée &ldquo;Weight&rdquo;. Dans la première colonne figureront vos mots-clés, dans la deuxième colonne, vos mots-clés à nouveau (simple copier/coller) et dans la troisième colonne les volumes de recherche. Enregistrez votre fichier au format CSV, sous le nom <strong>nodes.csv</strong>. Votre fichier &ldquo;noeuds&rdquo; est prêt à être importé dans Gephi. Nous y reviendrons tout à l&#39;heure.</p> <h2>2ème étape : calculer la similarité entre chaque mot-clé</h2> <h3>Normaliser les mots-clés</h3> <p>Avant de passer au calcul de la similarité, nous allons d&#39;abord procéder à un ensemble de pré-traitements, en Ruby, qui nous permettront de mieux regrouper nos mots-clés. Reprenons le même jeu de données que dans l&#39;article précédent, que nous allons stocker dans un tableau.</p> <div class=highlight><pre class="highlight ruby"><code><span class="n">keywords</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"consultant seo"</span><span class="p">,</span><span class="s2">"référencement naturel"</span><span class="p">,</span><span class="s2">"expert seo"</span><span class="p">,</span><span class="s2">"referencement naturel"</span><span class="p">,</span><span class="s2">"consultant referencement"</span><span class="p">,</span><span class="s2">"consultant référencement"</span><span class="p">,</span><span class="s2">"agence de référencement"</span><span class="p">,</span><span class="s2">"agence seo"</span><span class="p">,</span><span class="s2">"consultant en référencement"</span><span class="p">,</span><span class="s2">"expert referencement"</span><span class="p">,</span><span class="s2">"agence référencement"</span><span class="p">,</span><span class="s2">"consultant référencement naturel"</span><span class="p">,</span><span class="s2">"agence referencement"</span><span class="p">,</span><span class="s2">"consultant en referencement"</span><span class="p">,</span><span class="s2">"agence de referencement"</span><span class="p">,</span><span class="s2">"référencement seo"</span><span class="p">,</span><span class="s2">"experts referencement"</span><span class="p">,</span><span class="s2">"référenceur freelance"</span><span class="p">,</span><span class="s2">"consultant référencement internet"</span><span class="p">,</span><span class="s2">"expert référencement"</span><span class="p">,</span><span class="s2">"consultant referencement naturel"</span><span class="p">,</span><span class="s2">"consultant en référencement naturel"</span><span class="p">,</span><span class="s2">"conseil seo"</span><span class="p">,</span><span class="s2">"referenceur freelance"</span><span class="p">,</span><span class="s2">"spécialiste référencement naturel"</span><span class="p">,</span><span class="s2">"search engine optimization for dummies"</span><span class="p">,</span><span class="s2">"seo referencement"</span><span class="p">,</span><span class="s2">"consultant en referencement naturel"</span><span class="p">,</span><span class="s2">"devis referencement"</span><span class="p">,</span><span class="s2">"top seo company"</span><span class="p">,</span><span class="s2">"expert référencement naturel"</span><span class="p">]</span>
</code></pre></div> <p>La première étape consiste à transformer chaque expression-clé en tokens. Voici comme je procède : je découpe chaque chaîne de caractères dès que je trouve un espace.</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">get_tokens_from</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
  <span class="n">tokens</span> <span class="o">=</span> <span class="n">string</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">' '</span><span class="p">)</span>
  <span class="n">tokens</span>
<span class="k">end</span>
</code></pre></div> <p>Une fois la tokenisation effectuée, je vais chercher dans une base de données de lemmes (voir mon article <a href="http://www.antoine-brisset.com/blog/seo-campus-lille-2016/">sur l&#39;analyse sémantique</a>), la correspondance entre chaque token et son lemme. J&#39;utilise également le framework Treat pour déterminer la catégorie morpho-syntaxique de chaque mot et ainsi lever l&#39;ambiguïté lorsque plusieurs lemmes sont possibles pour un même token.</p> <p>La méthode ci-dessous retrouve en base de données, pour chaque token, le lemme qui lui est associé, puis stocke le tout dans un tableau et élimine les accents et les stop words (deux fonctions très simples sont utilisées pour ces opérations, <code>remove_accents_from</code> et <code>delete_stop_words_from</code>, que je ne détaillerai pas ici).</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">get_lemmatised_words_from</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
  <span class="n">keywords</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">tokens</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">w</span><span class="o">|</span>
    <span class="k">begin</span>
      <span class="n">word_str</span> <span class="o">=</span> <span class="vg">$client</span><span class="p">.</span><span class="nf">escape</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
      <span class="n">rows</span>     <span class="o">=</span> <span class="vg">$client</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="s2">"SELECT lemma,word,category
                                FROM lemmas
                                WHERE word   = '</span><span class="si">#{</span><span class="n">word_str</span><span class="si">}</span><span class="s2">' COLLATE utf8_bin
                                AND category = '</span><span class="si">#{</span><span class="n">w</span><span class="p">.</span><span class="nf">category</span><span class="si">}</span><span class="s2">'
                                LIMIT 1"</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">rows</span><span class="p">.</span><span class="nf">size</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">keywords</span> <span class="o">&lt;&lt;</span> <span class="n">remove_accents_from</span><span class="p">(</span><span class="n">rows</span><span class="p">.</span><span class="nf">map</span><span class="p">{</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span> <span class="n">row</span><span class="p">[</span><span class="s2">"lemma"</span><span class="p">]</span> <span class="p">}.</span><span class="nf">first</span><span class="p">)</span>
      <span class="k">else</span>
        <span class="n">keywords</span> <span class="o">&lt;&lt;</span> <span class="n">remove_accents_from</span><span class="p">(</span><span class="n">word_str</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
      <span class="nb">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">w</span><span class="si">}</span><span class="s2"> =&gt; </span><span class="si">#{</span><span class="n">e</span><span class="si">}</span><span class="s2">"</span>
      <span class="k">next</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">delete_stop_words_from</span><span class="p">(</span><span class="n">keywords</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div> <h3>Calculer le coefficient de Dice</h3> <p>On peut maintenant passer à la première étape du partitionnement. Comme expliqué <a href="https://www.amazon.fr/Recherche-dinformation-Applications-algorithmes-d%C3%A9cisionnel/dp/2212135327/?tag=antoine-brisset-21">dans le livre de Massih-Reza Amini et Éric Gaussuier</a>, lors de tout travail de partitionnement, la 1ère étape consiste à choisir &ldquo;une mesure de similarité&rdquo; entre les documents. Plusieurs mesures de similarité sont présentées dans ce livre, et notamment le <em>coefficient de Dice</em>, que j&#39;ai retenu pour mon analyse. Il est assez proche de l&rsquo;<strong>indice de Jaccard</strong> et se calcule en divisant le double l&#39;intersection de deux ensembles, par l&#39;union de ces deux ensembles.</p> <p>La méthode ci-dessous passe en revue chaque mot-clé, calcule leur similarité un à un via le coeficient de Dice, puis stocke les résultats dans un tableau.</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">get_results_from</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">results</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">data</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">|</span>
    <span class="n">data</span><span class="p">.</span><span class="nf">dup</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">kb</span><span class="p">,</span> <span class="n">vb</span><span class="o">|</span>
      <span class="n">dice</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="n">vb</span><span class="p">).</span><span class="nf">count</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">/</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="nf">count</span> <span class="o">+</span> <span class="n">vb</span><span class="p">.</span><span class="nf">count</span><span class="p">)</span>
      <span class="n">dice</span> <span class="o">=</span> <span class="n">dice</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
      <span class="n">results</span> <span class="o">&lt;&lt;</span> <span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">kb</span><span class="p">,</span> <span class="n">dice</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">results</span>
<span class="k">end</span>
</code></pre></div> <p>Il ne reste plus qu&#39;à créer le fichier <strong>edges.csv</strong>, qui indiquera à Gephi le degré &ldquo;d&#39;attirance&rdquo; entre chaque noeud.</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">make_edges_csv_file_from</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="no">CSV</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s2">"./edges.csv"</span><span class="p">,</span> <span class="s2">"wb"</span><span class="p">,</span> <span class="p">{</span><span class="ss">:col_sep</span> <span class="o">=&gt;</span> <span class="s2">";"</span><span class="p">})</span> <span class="k">do</span> <span class="o">|</span><span class="n">csv</span><span class="o">|</span>
    <span class="n">csv</span> <span class="o">&lt;&lt;</span> <span class="p">[</span><span class="s2">"source"</span><span class="p">,</span> <span class="s2">"target"</span><span class="p">,</span> <span class="s2">"weight"</span><span class="p">]</span>
    <span class="n">array</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span>
      <span class="n">csv</span> <span class="o">&lt;&lt;</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div> <p>Et voilà, nous avons maintenant toutes les données nécessaires, passons à l&#39;utilisation de Gephi ! Pour ceux que ça intéresse, le code complet est ici : <a href="https://gist.github.com/ABrisset/661a87fb11a16807cf4ae984e7df8c13">https://gist.github.com/ABrisset/661a87fb11a16807cf4ae984e7df8c13</a>.</p> <h2>3ème étape : visualiser les données dans Gephi</h2> <h3>Importer les données</h3> <p>Ouvrez Gephi, cliquez sur &ldquo;Fichier &gt; Nouveau Projet&rdquo;, puis rendez-vous dans &ldquo;Laboratoire de données&rdquo;, et cliquez sur &ldquo;Importer feuille de calcul&rdquo;.</p> <p>Allez rechercher votre fichier <strong>edges.csv</strong>. C&#39;est lui qui indiquera à Gephi quel est le degré d&#39;attirance entre chaque paire de mots. Sélectionnez &ldquo;En tant que table des liens&rdquo;, choisissez le bon séparateur, puis cliquez sur suivant. Dans la fenêtre suivante, cochez &ldquo;Créer les noeuds manquants&rdquo;, puis cliquez sur &ldquo;Terminer&rdquo;.</p> <p><img src="/images/posts/edges.png" title=Liens alt="Edges - Gephi"/></p> <p>Ensuite, répétez la même opération, mais cette fois pour les noeuds. Il faut sélectionner &ldquo;En tant que table des noeuds&rdquo;, puis à la fenêtre suivante, renseigner &ldquo;Integer&rdquo; en tant que type de données pour le champ &ldquo;Weight&rdquo; et veiller à bien décocher &ldquo;Forcer les noeuds importés à être de nouveaux noeuds&rdquo;.</p> <p>Grâce à la colonne &ldquo;Id&rdquo; de votre fichier noeuds, Gephi est en mesure d&#39;identifier quels sont les noeuds dans les liaisons &ldquo;Source&rdquo; et &ldquo;Target&rdquo;.</p> <p><img src="/images/posts/nodes_1.png" title="Noeuds - étape 1" alt="Nodes - Gephi"/></p> <p><img src="/images/posts/nodes_2.png" title="Noeuds - étape 2" alt="Nodes (2) - Gephi"/></p> <h3>Jouer avec les paramètres de Gephi</h3> <p>La dernière étape consiste à customiser les noeuds et les liens en fonction de notre objectif de clusterisation. Rendez-vous dans &ldquo;Vue d&#39;ensemble&rdquo;.</p> <p>Tout d&#39;abord, lancez l&#39;algorithme &ldquo;Modularity&rdquo; via le panel de droite. Celui-ci permet d&#39;identifier des communautés dans une structure de graphes. Plus d&#39;infos <a href="https://github.com/gephi/gephi/wiki/Modularity">ici</a>. Ensuite, dans le panel de gauche, cliquez sur &ldquo;Partition&rdquo; puis &ldquo;Noeuds&rdquo; et choisissez &ldquo;Modularity Class&rdquo;. Trois clusters différents ont été trouvés : les noeuds se colorent en fonction de leur &ldquo;communauté&rdquo; de rattachement.</p> <p><img src="/images/posts/modularity.png" title=Modularity alt="Modularity - Gephi"/></p> <p>Basculez sur l&#39;onglet &ldquo;Classement&rdquo;, choisissez &ldquo;Noeuds&rdquo; et dans &ldquo;Taille/Poids&rdquo;, sélectionnez &ldquo;Weight&rdquo; : les noeuds sont désormais de taille proportionnelle au volume de recherche. Vous pouvez procéder de la même façon pour la taille des labels.</p> <p><img src="/images/posts/weight.png" title=Weight alt="Weight - Gephi"/></p> <p>Il ne reste plus qu&#39;à ajouter un peu de spatialisation. Pour cela, utilisons Force Atlas 2, avec les paramètres ci-dessous.</p> <p><img src="/images/posts/spatialisation.png" title="Force Atlas" alt="Force Atlas - Gephi"/></p> <h3>Exporter la visualisation</h3> <p>Laissons Force Atlas tourner quelques instants. Direction maintenant l&#39;onglet &ldquo;Visualisation&rdquo;. Vous devriez obtenir la visualisation ci-dessous, avec 3 clusters :</p> <ul> <li>mots-clés autour de &ldquo;référencement&rdquo; + &ldquo;site&rdquo;</li> <li>mots-clés autour de &ldquo;seo&rdquo;</li> <li>mots-clés autour de &ldquo;référencement&rdquo; + &ldquo;agence&rdquo;, &ldquo;naturel&rdquo;, etc.</li> </ul> <p>Un conseil : ouvrez l&#39;image dans un nouvel onglet et téléchargez l&#39;extension Chrome SVG Navigator pour zoomer ;)</p> <p><img src="/images/posts/seo.svg" title="Visualisation des clusters" alt="SEO visualisation"/></p> <p>Que pensez-vous de cette visualisation ? Pour ma part, je trouve que c&#39;est un bon moyen de dégrossir une thématique et d&#39;identifier rapidement les chantiers SEO prioritaires, c&#39;est-à-dire les territoires sémantiques sur lesquels concentrer ses efforts.</p> <p>Je pense, néanmoins, que l&#39;on pourrait obtenir une meilleure granularité en comparant les n-grammes entre eux, et non uniquement les mots. À suivre ;)</p> <div id=disqus_thread></div> <script>
//<![CDATA[
                  var disqus_shortname = 'blogantoinebrisset';
          
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
//]]>
</script> <noscript>Please enable JavaScript to view the <a href='http://disqus.com/?ref_noscript'>comments powered by Disqus.</a></noscript> <a href='http://disqus.com' class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a> </article></div></div><footer class=footer><div role=content-info><ul class=footer__content><li class=footer__content__item><i class="fa fa-home"></i> Marquette-lez-Lille</li><li class=footer__content__item><i class="fa fa-phone"></i> 06 12 71 82 78</li><li class=footer__content__item><i class="fa fa-envelope"></i> <a href="#email-protection-pbagnpg@nagbvar-oevffrg.pbz">contact@antoine-brisset.com</a> </li></ul><ul class=footer__content--social><li class=footer__content__item--social><a href="https://twitter.com/abrisset"><i class='fa fa-twitter footer__icon'></i></a></li><li class=footer__content__item--social><a href="https://github.com/ABrisset"><i class='fa fa-github footer__icon'></i></a></li><li class=footer__content__item--social><a href="http://plus.google.com/112811217796192792405?rel=author"><i class='fa fa-google-plus footer__icon'></i></a></li></ul><div class=footer__copyright> &copy; 2019 - <a href="/">Antoine Brisset</a></div></div></footer><script type="text/javascript">!function(){try{var a,b,c,d,g=document.getElementsByTagName("a");for(c=0;g.length-c;c++)try{b=g[c].getAttribute("href"),b&&b.indexOf("#email-protection-")>-1&&b.length>19&&(a="",d=19+b.indexOf("#email-protection-"),b.length>d&&(a=b.substr(18).replace(/[a-zA-Z]/g,function(a){return String.fromCharCode(("Z">=a?90:122)>=(a=a.charCodeAt(0)+13)?a:a-26)})),g[c].setAttribute("href","mailto:"+a))}catch(h){}}catch(h){}}();</script>
</body></html>