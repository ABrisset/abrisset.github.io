<!DOCTYPE html><html lang=fr><head><meta charset=utf-8 /><meta content="width=device-width,initial-scale=1" name=viewport /><title>SEO Ruby on Rails : bonnes pratiques (1ère partie) &bull; Antoine Brisset</title><meta content="Découvrez dans ce premier article quelques astuces pour optimiser le référencement de votre application Ruby on Rails" name=description /><meta content="index,follow" name=robots /><meta content=R7aPiADkUTnBNzbTvsqutfN3_gewIxUFwJpKYyc-hBQ name=google-site-verification /><link href="/apple-touch-icon.png" rel=apple-touch-icon sizes=57x57 /><link href="/apple-touch-icon-57x57-precomposed.png" rel=apple-touch-icon sizes=57x57 /><link href="/apple-touch-icon-60x60-precomposed.png" rel=apple-touch-icon sizes=60x60 /><link href="/apple-touch-icon-72x72-precomposed.png" rel=apple-touch-icon sizes=72x72 /><link href="/apple-touch-icon-76x76-precomposed.png" rel=apple-touch-icon sizes=76x76 /><link href="/apple-touch-icon-114x114-precomposed.png" rel=apple-touch-icon sizes=114x114 /><link href="/apple-touch-icon-120x120-precomposed.png" rel=apple-touch-icon sizes=120x120 /><link href="/apple-touch-icon-144x144-precomposed.png" rel=apple-touch-icon sizes=144x144 /><link href="/apple-touch-icon-152x152-precomposed.png" rel=apple-touch-icon sizes=152x152 /><link href="/favicon-196x196.png" rel=icon sizes=196x196 type="image/png"/><link href="/favicon-160x160.png" rel=icon sizes=160x160 type="image/png"/><link href="/favicon-96x96.png" rel=icon sizes=96x96 type="image/png"/><link href="/favicon-32x32.png" rel=icon sizes=32x32 type="image/png"/><link href="/favicon-16x16.png" rel=icon sizes=16x16 type="image/png"/><meta content="#f5f5f5" name=msapplication-TileColor /><meta content="/mstile-144x144.png" name=msapplication-TileImage /><link href="/stylesheets/application.css" rel=stylesheet /><link href="//fonts.googleapis.com/css?family=Open+Sans:400,300,600,700,800" rel=stylesheet /><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel=stylesheet /><style>.header{background-image: url('/images/backgrounds/small/train.jpg');}
    @media screen and (min-width: 25em){.header{background-image: url('/images/backgrounds/medium/train.jpg');}}
    @media screen and (min-width: 50em){.header{background-image: url('/images/backgrounds/train.jpg');}}</style><script src="/javascripts/all.js"></script></head><body class="blog blog_seo-ruby-on-rails-1 blog_seo-ruby-on-rails-1_index"> <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-WW7MSH" height=0 width=0 style="display:none;visibility:hidden"></iframe></noscript> <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-NKG6T7');</script> <div class=wrapper><nav role=navigation><div class=fat-nav><div class=fat-nav__wrapper><ul><li><a href="/">Accueil</a></li><li><a href="/blog/">Blog SEO</a></li><li><a href="/#contact">Contact</a></li></ul></div></div></nav></div><div role=main></div><div class=header><div class=wrapper><h1 class=header__title>Bonnes pratiques SEO sous Ruby on Rails - 1ère partie</h1><p class=header__category><i class="fa fa-tag"></i> <em>SEO On-site</em></p></div></div><div class="section section__content--large"><div class=wrapper><article class=blog__article><p class=blog__breadcrumb><a href="/blog/">Blog SEO</a> / <a href="/blog/categories/seo-on-site/">SEO On-site</a></p><p class=blog__date>Publié le 27 May 2015</p><p class=blog__chapo>Après avoir passé quelques années à bidouiller des petits scripts en Ruby, je me suis lancé l’année dernière dans l’apprentissage de Ruby on Rails, grâce notamment à <a href='http://www.amazon.fr/Ruby-Rails-4-0-Guide-guide/dp/1491054484/?_encoding=UTF8&camp=1642&creative=6746&linkCode=ur2&tag=antoine-brisset-21'>ce livre de Stefan Wintermeyer</a>, que je recommande d’ailleurs vivement à tous ceux qui seraient désireux d’apprendre les bases de RoR. N’étant pas développeur de formation, ce framework est pour moi vraiment intéressant dans le sens où il permet de développer rapidement et sans trop de prise de tête des applications plus ou moins complexes. Ayant suffisamment de recul sur le fonctionnement de Rails, je vous propose une série d’articles sous forme d’astuces pour optimiser les fondamentaux SEO de votre application Ruby on Rails. C’est parti pour la 1ère partie !</p><h2>Réécriture d&#39;URL</h2> <p>Par défaut, Rails utilise la clé primaire id pour la génération des URL. Par exemple, s&#39;il reçoit une requête de type GET /photos/3, le fichier routes.rb va transmettre la requête au controller &ldquo;photos_controller&rdquo;, en passant en paramètre à l&#39;action &ldquo;show&rdquo; la valeur de l&#39;id. Rails va donc être en mesure de retrouver l&#39;objet associé en recherchant dans le modèle &ldquo;Photo&rdquo; l&#39;objet ayant pour id &ldquo;3&rdquo;.</p> <p>Cela fonctionne très bien, certes, mais ce n&#39;est pas optimal d&#39;un point de vue SEO. Si j&#39;ai tendance à considérer que l&#39;ajout de mots-clés dans l&#39;URL n&#39;est pas impératif en termes de ranking, je pense néanmoins que dans les SERP, avoir le mot-clé en gras au lieu d&#39;un simple id est un petit plus visuel qui peut booster votre CTR.</p> <p>Alors, comment faire pour rendre les URL plus sexy ? Une première solution pourrait être de surcharger la méthode to_param, qui, grosso modo, gère la construction des chemins d&#39;URL. Quelque chose de ce type, dans le modèle :</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">to_param</span>
  <span class="s2">"</span><span class="si">#{</span><span class="nb">id</span><span class="si">}</span><span class="s2">-</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">parameterize</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div> <p>Dans le cas où notre table photos dispose d&#39;une colomne &ldquo;name&rdquo;, les URL générées pour chaque objet photo reprendront l&#39;id, suivi du nom, lequel aura été débarrassé de tout caractère spécial, via la méthode &ldquo;parameterize&rdquo;.</p> <p>C&#39;est une solution intéressante mais qui présente un gros défaut : avant de lancer la requête SQL lui permettant de rechercher à quel objet correspond l&#39;id reçu en paramètre, Rails va convertir cet id en entier via la méthode to_i. Ce qui signifie, par exemple, que &ldquo;1-toto&rdquo; va devenir &ldquo;1&rdquo;. Vous voyez où je veux en venir ? Si quelqu&#39;un s&#39;amuse à générer des URL de type &ldquo;1-lolilol&rdquo; ou &ldquo;1-trololo&rdquo;, Rails va quand même renvoyer l&#39;objet ayant pour id &ldquo;1&rdquo; et afficher la page, laissant la porte ouverte à des attaques de negative SEO à coup de duplicate d&#39;URL.</p> <p>Je vous conseille donc d&#39;utiliser un système plus robuste, qui se débarrassera complètement de l&#39;id et reposera sur un autre attribut du modèle. Par exemple, dans le cas de notre modèle Photo, l&#39;attribut name. On pourrait faire cela &ldquo;à la main&rdquo; :</p> <ul> <li>on ajoute un nouvel attribut à notre modèle, par exemple &ldquo;slug&rdquo; (il faut prévoir la migration de la base)</li> </ul> <div class=highlight><pre class="highlight console"><code><span class="go">rails g migration AddSlugToPhotos slug:string
rake db:migrate
</span></code></pre></div> <ul> <li>on l&#39;ajoute à notre liste de paramètres autorisés, au niveau du controller</li> </ul> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">photo_params</span>
  <span class="n">params</span><span class="p">.</span><span class="nf">required</span><span class="p">(</span><span class="ss">:photo</span><span class="p">).</span><span class="nf">permit</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:slug</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div> <ul> <li>on valide sa présence lors de chaque nouvel item créé, au niveau du modèle</li> </ul> <div class=highlight><pre class="highlight ruby"><code><span class="n">validates</span> <span class="ss">:slug</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span><span class="p">,</span> <span class="ss">uniqueness: </span><span class="kp">true</span>
</code></pre></div> <ul> <li>on modifie la la méthode to_param, au niveau du modèle</li> </ul> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">to_param</span>
  <span class="n">slug</span>
<span class="k">end</span>
</code></pre></div> <ul> <li>pour chaque appel à la méthode find, il faudra désormais utiliser la méthode &ldquo;find<em>by</em>slug&rdquo; et non plus &ldquo;find&rdquo;, puisque cette dernière recherche les enregistrements de la base de données par id.</li> </ul> <p>Pour aller beaucoup plus vite, dans cet esprit, il existe une gem très complète : <a href="https://github.com/norman/friendly_id">friendly_id</a>. Une fois la gem installée, il suffit de d&#39;ajouter les méthodes de la classe FriendlyId à notre modèle</p> <div class=highlight><pre class="highlight ruby"><code><span class="kp">extend</span> <span class="no">FriendlyId</span>
</code></pre></div> <p>Puis de spécifier quel attribut sera utilisé pour la génération du slug (ici, &ldquo;name&rdquo;)</p> <div class=highlight><pre class="highlight ruby"><code><span class="n">friendly_id</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">use: :slugged</span>
</code></pre></div> <p>Et enfin, de remplacer la méthode <em>find</em> par <em>friendly.find</em>, chaque fois que vous l&#39;utilisez dans vos vues et/ou controllers.</p> <p>Et voilà ! On se retrouve avec de belles URL contenant nos mots-clés. Petite précision concernant les URL sous Rails : par défaut Rails utilise les cookies pour stocker les infos de session. Donc a priori, vous n&#39;aurez jamais de souci avec des id de session présents dans les URL qui pourraient créer du duplicate d&#39;URL.</p> <h2>Balises title &amp; meta</h2> <p>Le contenu de la balise title est l&#39;un des critères SEO les plus importants, c&#39;est d&#39;ailleurs <a href="http://www.seo-factors.com/fr/">un consensus auprès des référenceurs</a>. Dans une application Ruby on Rails, il faut donc disposer a minima d&#39;un système permettant de personnaliser les balises title et meta (description, robots) pour chaque page / template.</p> <p>Pour faire cela proprement et simplement, on pourrait par exemple s&#39;aider d&#39;une méthode qu&#39;on ajouterait dans le helper de l&#39;application. L&#39;idée étant de ne pas surcharger nos vues. Par exemple, on pourrait ajouter une méthode telle que celle-ci dans notre fichier application_helper.rb</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">title</span><span class="p">(</span><span class="n">title_content</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">title_content</span><span class="p">.</span><span class="nf">present?</span> <span class="c1"># si le paramètre title_content est présent</span>
    <span class="n">title_content</span> <span class="o">&lt;&lt;</span> <span class="s2">" | Mon Site"</span> <span class="c1"># le title reprendra la chaîne en paramètre suivie de " | Mon Site"</span>
  <span class="k">else</span>
    <span class="s2">"Mon Site"</span> <span class="c1"># sinon, par défaut, le title sera "Mon site"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div> <p>Dans le layout de l&#39;application, il faudrait donc dynamiser cette partie (ici sous slim) :</p> <div class=highlight><pre class="highlight ruby"><code><span class="n">title</span>
  <span class="o">=</span> <span class="k">yield</span><span class="p">(</span><span class="ss">:title</span><span class="p">)</span>
</code></pre></div> <p>Puis, dans chaque vue, utiliser la méthode content_for qui fera appel à notre helper, de cette manière :</p> <div class=highlight><pre class="highlight ruby"><code><span class="o">=</span> <span class="n">content_for</span> <span class="ss">:title</span><span class="p">,</span> <span class="n">title</span><span class="p">(</span><span class="s2">"Mon titre avec mots-clés"</span><span class="p">)</span>
</code></pre></div> <p>Vous pourriez vous inspirer de ce helper pour gérer, de la même façon, les balises meta description et meta robots.</p> <p><u>MAJ du 01/06/2015</u></p> <p>Suite à cet <a href="http://www.lewagon.org/blog/tuto-setup-metatags-rails">excellent article</a> publié par le Wagon, je vous conseille de définir les valeurs par défaut de vos balises meta dans un fichier yaml à placer directement dans le dossier config/initializers (exemple: meta.rb)</p> <div class=highlight><pre class="highlight yaml"><code><span class="na">default_title</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Mon</span><span class="nv"> </span><span class="s">Site"</span>
</code></pre></div> <p>Puis de charger celui-ci dans le fichier environnement.rb :</p> <div class=highlight><pre class="highlight ruby"><code><span class="no">DEFAULT_META</span> <span class="o">=</span> <span class="no">YAML</span><span class="p">.</span><span class="nf">load_file</span><span class="p">(</span><span class="no">Rails</span><span class="p">.</span><span class="nf">root</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">'/config/meta.yml'</span><span class="p">))</span>
</code></pre></div> <p>Ce qui vous permettra, dans votre helper, de faire la chose suivante :</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">title</span><span class="p">(</span><span class="n">title_content</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">title_content</span><span class="p">.</span><span class="nf">present?</span>
    <span class="n">title_content</span> <span class="o">&lt;&lt;</span> <span class="s2">" | "</span> <span class="o">+</span> <span class="no">DEFAULT_META</span><span class="p">[</span><span class="s1">'title'</span><span class="p">]</span>
  <span class="k">else</span>
    <span class="no">DEFAULT_META</span><span class="p">[</span><span class="s1">'title'</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div> <p>Si vous souhaitez faire plus simple (ou aller plus vite, à vous de voir), je vous conseille d&#39;utiliser la gem <a href="https://github.com/kpumuk/meta-tags">meta_tags</a>. Elle permet de définir et de personnaliser vos balises title, meta, open graph, twitter cards, hreflang et bien d&#39;autres, que ce soit au niveau de votre controller ou au niveau de votre vue. Un outil vraiment très bien pensé, intuitif, qui vous rendra service si vous souhaitez optimiser dans le détail toutes ces balises sans réinventer la roue.</p> <p>Si je reprends mon modèle Photo, et que je souhaite par exemple définir les title et meta description de chaque item Photo, voici comment je devrai procéder :</p> <ul> <li>d&#39;abord, ajouter la méthode dans le layout de l&#39;application</li> </ul> <div class=highlight><pre class="highlight ruby"><code><span class="n">display_meta_tags</span> <span class="ss">:site</span> <span class="o">=&gt;</span> <span class="s1">'Mon Site'</span><span class="p">,</span> <span class="ss">:reverse</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">:separator</span> <span class="o">=&gt;</span> <span class="s2">"|"</span>
</code></pre></div> <ul> <li>puis setter les bonnes variables dans le controller photos_controller#show</li> </ul> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">show</span>
  <span class="vi">@photo</span> <span class="o">=</span> <span class="no">Photo</span><span class="p">.</span><span class="nf">friendly</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">])</span>
  <span class="n">set_meta_tags</span> <span class="ss">:title</span> <span class="o">=&gt;</span> <span class="s1">'@photo.name'</span><span class="p">,</span>
                <span class="ss">:description</span> <span class="o">=&gt;</span> <span class="s1">'@photo.name : découvrez ma jolie photo !'</span><span class="p">,</span>
                <span class="ss">:robots</span> <span class="o">=&gt;</span> <span class="s1">'index, follow'</span>
<span class="k">end</span>
</code></pre></div> <h2>Robots.txt</h2> <p>Le fichier robots.txt est un fichier tout bête à première vue et pourtant, c&#39;est celui pour lequel Googlebot a le plus d&#39;appétance. En effet, c&#39;est dans celui-ci que sont contenues les directives de crawl de votre site. Une erreur de syntaxe, et ça peut être la catastrophe !</p> <p>Pour la gestion de ce fichier, plusieurs options sont possibles sous Rails.</p> <h3>1ère option</h3> <p>Tout d&#39;abord, vous pouvez créer ce fichier et le placer dans le dossier public de votre application. Il sera alors disponible directement à la racine de votre site. Oui, mais problème : pour chacun de vos environnements, le contenu de ce fichier sera le même. Donc si en prod, vous avez un joli</p> <div class=highlight><pre class="highlight plaintext"><code>User-Agent: *
Allow: /
</code></pre></div> <p>&hellip; alors votre environnement de préprod contiendra les mêmes directives et risquera de se faire crawler et donc indexer, dans l&#39;éventualité bien sûr où celui-ci n&#39;est pas protégé par authentification (login / mot de passe). Pas top donc. Passons à la 2ème option.</p> <h3>2ème option</h3> <p>La 2ème option est de loin la meilleure, mais elle nécessite un peu plus de travail. En effet, nous allons utiliser un controller spécifique qui interceptera toutes les requêtes de type GET /robots.txt. Pour cela, commençons par mettre à jour notre fichier routes.rb</p> <div class=highlight><pre class="highlight ruby"><code><span class="n">get</span> <span class="s1">'/robots.:format'</span> <span class="o">=&gt;</span> <span class="s1">'pages#robots'</span>
</code></pre></div> <p>Ici, nous allons transmettre la requête à un controller &ldquo;pages&rdquo; et plus spécifiquement à l&#39;action &ldquo;robots&rdquo;. Voyons voir le contenu de notre méthode robots :</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">robots</span>
  <span class="n">respond_to</span> <span class="ss">:text</span>
<span class="k">end</span>
</code></pre></div> <p>Rien de bien sorcier, elle s&#39;occupe simplement de &ldquo;répondre&rdquo; à la requête en renvoyant un contenu au format texte. Passons à notre vue, rendez-vous dans views &gt; pages &gt; robots.text.slim. C&#39;est ici que ça devient intéressant. Car, oui, nous allons pouvoir dynamiser notre fichier robots.txt, c&#39;est-à-dire renvoyer un contenu différent selon que l&#39;on soit sur l&#39;environnement de production ou sur l&#39;environnement de développement / staging / recette.</p> <div class=highlight><pre class="highlight ruby"><code><span class="o">-</span> <span class="k">if</span> <span class="no">Rails</span><span class="p">.</span><span class="nf">env</span> <span class="o">==</span> <span class="s2">"production"</span>
  <span class="o">=</span> <span class="s2">"User-Agent: *</span><span class="se">\n</span><span class="s2">"</span>
  <span class="o">=</span> <span class="s2">"Disallow: /admin"</span>
<span class="o">-</span> <span class="k">else</span>
  <span class="o">=</span> <span class="s2">"User-Agent: *</span><span class="se">\n</span><span class="s2">"</span>
  <span class="o">=</span> <span class="s2">"Noindex: /"</span>
<span class="k">end</span>
</code></pre></div> <p>Grâce à cette astuce, vous maîtrisez parfaitement votre indexation sur chacun de vos environnements !</p> <p>La suite des astuces d&#39;optimisation de votre référencement naturel sous Ruby on Rails, c&#39;est <a href="http://www.antoine-brisset.com/blog/seo-ruby-on-rails-2/">ici</a> !</p> <div id=disqus_thread></div> <script>
//<![CDATA[
                  var disqus_shortname = 'blogantoinebrisset';
          
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
//]]>
</script> <noscript>Please enable JavaScript to view the <a href='http://disqus.com/?ref_noscript'>comments powered by Disqus.</a></noscript> <a href='http://disqus.com' class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a> </article></div></div><footer class=footer><div role=content-info><ul class=footer__content><li class=footer__content__item><i class="fa fa-home"></i> Marquette-lez-Lille</li><li class=footer__content__item><i class="fa fa-phone"></i> 06 12 71 82 78</li><li class=footer__content__item><i class="fa fa-envelope"></i> <a href="#email-protection-pbagnpg@nagbvar-oevffrg.pbz">contact@antoine-brisset.com</a> </li></ul><ul class=footer__content--social><li class=footer__content__item--social><a href="https://twitter.com/abrisset"><i class='fa fa-twitter footer__icon'></i></a></li><li class=footer__content__item--social><a href="https://github.com/ABrisset"><i class='fa fa-github footer__icon'></i></a></li><li class=footer__content__item--social><a href="http://plus.google.com/112811217796192792405?rel=author"><i class='fa fa-google-plus footer__icon'></i></a></li></ul><div class=footer__copyright> &copy; 2019 - <a href="/">Antoine Brisset</a></div></div></footer><script type="text/javascript">!function(){try{var a,b,c,d,g=document.getElementsByTagName("a");for(c=0;g.length-c;c++)try{b=g[c].getAttribute("href"),b&&b.indexOf("#email-protection-")>-1&&b.length>19&&(a="",d=19+b.indexOf("#email-protection-"),b.length>d&&(a=b.substr(18).replace(/[a-zA-Z]/g,function(a){return String.fromCharCode(("Z">=a?90:122)>=(a=a.charCodeAt(0)+13)?a:a-26)})),g[c].setAttribute("href","mailto:"+a))}catch(h){}}catch(h){}}();</script>
</body></html>