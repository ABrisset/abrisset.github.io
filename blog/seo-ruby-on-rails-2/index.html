<!DOCTYPE html><html lang=fr><head><meta charset=utf-8 /><meta content="width=device-width,initial-scale=1" name=viewport /><title>SEO Ruby on Rails : bonnes pratiques (2ème partie) &bull; Antoine Brisset</title><meta content="Découvrez, dans ce deuxième article, de nouvelles pistes d'optimisation SEO pour votre application Ruby on Rails ! Au programme : redirection www, sitemap.xml et erreur 404..." name=description /><meta content="index,follow" name=robots /><meta content=R7aPiADkUTnBNzbTvsqutfN3_gewIxUFwJpKYyc-hBQ name=google-site-verification /><link href="/apple-touch-icon.png" rel=apple-touch-icon sizes=57x57 /><link href="/apple-touch-icon-57x57-precomposed.png" rel=apple-touch-icon sizes=57x57 /><link href="/apple-touch-icon-60x60-precomposed.png" rel=apple-touch-icon sizes=60x60 /><link href="/apple-touch-icon-72x72-precomposed.png" rel=apple-touch-icon sizes=72x72 /><link href="/apple-touch-icon-76x76-precomposed.png" rel=apple-touch-icon sizes=76x76 /><link href="/apple-touch-icon-114x114-precomposed.png" rel=apple-touch-icon sizes=114x114 /><link href="/apple-touch-icon-120x120-precomposed.png" rel=apple-touch-icon sizes=120x120 /><link href="/apple-touch-icon-144x144-precomposed.png" rel=apple-touch-icon sizes=144x144 /><link href="/apple-touch-icon-152x152-precomposed.png" rel=apple-touch-icon sizes=152x152 /><link href="/favicon-196x196.png" rel=icon sizes=196x196 type="image/png"/><link href="/favicon-160x160.png" rel=icon sizes=160x160 type="image/png"/><link href="/favicon-96x96.png" rel=icon sizes=96x96 type="image/png"/><link href="/favicon-32x32.png" rel=icon sizes=32x32 type="image/png"/><link href="/favicon-16x16.png" rel=icon sizes=16x16 type="image/png"/><meta content="#f5f5f5" name=msapplication-TileColor /><meta content="/mstile-144x144.png" name=msapplication-TileImage /><link href="/stylesheets/application.css" rel=stylesheet /><link href="//fonts.googleapis.com/css?family=Open+Sans:400,300,600,700,800" rel=stylesheet /><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel=stylesheet /><style>.header{background-image: url('/images/backgrounds/small/train.jpg');}
    @media screen and (min-width: 25em){.header{background-image: url('/images/backgrounds/medium/train.jpg');}}
    @media screen and (min-width: 50em){.header{background-image: url('/images/backgrounds/train.jpg');}}</style><script src="/javascripts/all.js"></script></head><body class="blog blog_seo-ruby-on-rails-2 blog_seo-ruby-on-rails-2_index"> <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-WW7MSH" height=0 width=0 style="display:none;visibility:hidden"></iframe></noscript> <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-NKG6T7');</script> <div class=wrapper><nav role=navigation><div class=fat-nav><div class=fat-nav__wrapper><ul><li><a href="/">Accueil</a></li><li><a href="/blog/">Blog SEO</a></li><li><a href="/#contact">Contact</a></li></ul></div></div></nav></div><div role=main></div><div class=header><div class=wrapper><h1 class=header__title>Bonnes pratiques SEO sous Ruby on Rails - 2ème partie</h1><p class=header__category><i class="fa fa-tag"></i> <em>SEO On-site</em></p></div></div><div class="section section__content--large"><div class=wrapper><article class=blog__article><p class=blog__breadcrumb><a href="/blog/">Blog SEO</a> / <a href="/blog/categories/seo-on-site/">SEO On-site</a></p><p class=blog__date>Publié le 17 Nov 2015</p><p class=blog__chapo>Dans le <a href='http://www.antoine-brisset.com/blog/seo-ruby-on-rails-1/'>1er article sur les bonnes pratiques SEO sous Ruby on Rails</a>, nous avons vu comment avoir des URL propres, optimiser ses balises title & meta et éditer facilement son fichier robots.txt. Voyons aujourd'hui comment forcer un domaine canonique (www), construire un fichier sitemap.xml, définir une page d'erreur 404 personnalisée et utiliser le cache HTTP.</p><h2>Forcer la redirection vers www</h2> <p>Si vous souhaitez forcer la redirection permanente vers le sous-domaine www de votre site, vous pouvez, au choix, ajouter la directive qui va bien au niveau du serveur, ou demander à votre application de faire le travail. Dans votre fichier <code>routes.rb</code>, il suffit d&#39;ajouter la contrainte suivante :</p> <div class=highlight><pre class="highlight ruby"><code><span class="n">constraints</span><span class="p">(</span><span class="ss">host: </span><span class="sr">/^(?!www\.)/i</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">match</span> <span class="s1">'(*any)'</span> <span class="o">=&gt;</span> <span class="n">redirect</span> <span class="p">{</span> <span class="o">|</span><span class="n">params</span><span class="p">,</span> <span class="n">request</span><span class="o">|</span>
    <span class="no">URI</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="nf">url</span><span class="p">).</span><span class="nf">tap</span> <span class="p">{</span> <span class="o">|</span><span class="n">uri</span><span class="o">|</span> <span class="n">uri</span><span class="p">.</span><span class="nf">host</span> <span class="o">=</span> <span class="s2">"www.</span><span class="si">#{</span><span class="n">uri</span><span class="p">.</span><span class="nf">host</span><span class="si">}</span><span class="s2">"</span> <span class="p">}.</span><span class="nf">to_s</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre></div> <p>Concrètement, la méthode vérifie au travers de l&#39;expression rationnelle <code>^(?!www\.)/i</code>, que ce qui apparait immédiatement au début de la chaine de caractères composant le host n&#39;est pas &ldquo;www.&rdquo;, c&#39;est-à-dire que la requête a été envoyée sans les www.</p> <p>Si c&#39;est bien le cas, la requête est capturée dans la méthode <code>match</code> puis passée à la méthode <code>redirect</code> qui va générer la redirection 301 vers la bonne URL. Cette méthode prend en argument les éventuels paramètres d&#39;URL, ainsi que l&#39;objet <code>request</code> et retourne en sortie une chaîne de caractères.</p> <p>Pour obtenir cette chaîne, un nouvel objet <code>URI</code> est instancié, auquel est passé en paramètre l&#39;URL de la requête. Son attribut host, enfin, est modifié en y ajoutant les &ldquo;www.&rdquo; grâce à la méthode <code>tap</code>. Et voilà, plus de problème de duplicate d&#39;URL !</p> <h2>Créer un sitemap.xml</h2> <p>L&#39;utilité d&#39;un sitemap.xml est <a href="http://www.creapulse.fr/le-sitemap-xml-cest-pas-bon-pour-le-seo/">controversée</a> mais reste un bon moyen, néanmoins, de faire connaître rapidement à Googlebot les nouvelles pages de son site.</p> <h3>1ère option : utiliser la gem Dynamic Sitemaps</h3> <p>Pour mettre en place un sitemap.xml avec Ruby on Rails, il existe plusieurs gems vraiment pratiques telles que <a href="https://github.com/lassebunk/dynamic_sitemaps">Dynamic Sitemaps</a>. Cette gem permet de définir plusieurs sitemaps, comme par exemple un premier sitemap regroupant des pages statiques et un second sitemap listant les items d&#39;un modèle. Elle permet également de définir le last_mod, de fixer des priorités de crawl et même de pinguer les moteurs de recherche chaque fois que le sitemap est mis à jour !</p> <p>Prenons l&#39;exemple d&#39;un blog qui contient une série d&#39;articles construits à partir du modèle <code>Article</code>, sur lequel a été défini un scope <code>published</code>, autrement dit :</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">scope</span> <span class="ss">:published</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span> <span class="ss">published: </span><span class="kp">true</span> <span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div> <p>Il est alors très facile avec <em>Dynamic Sitemaps</em> de générer le sitemap des articles, en créant le fichier <code>sitemap.rb</code> suivant dans le dossier <code>config</code> :</p> <div class=highlight><pre class="highlight ruby"><code><span class="c1"># on indique le domaine racine</span>
<span class="n">host</span> <span class="s2">"www.example.com"</span>

<span class="c1"># à ajouter seulement si vous votre site utilise le protocole https</span>
<span class="n">protocol</span> <span class="s2">"https"</span>

<span class="c1"># on boucle sur les articles</span>
<span class="n">sitemap_for</span> <span class="no">Article</span><span class="p">.</span><span class="nf">published</span><span class="p">,</span> <span class="ss">name: :articles</span> <span class="k">do</span> <span class="o">|</span><span class="n">article</span><span class="o">|</span>
  <span class="n">url</span> <span class="n">article</span><span class="p">,</span> <span class="ss">last_mod: </span><span class="n">article</span><span class="p">.</span><span class="nf">updated_at</span>
<span class="k">end</span>

<span class="c1"># on pinge Google</span>
<span class="n">ping_with</span> <span class="s2">"http://</span><span class="si">#{</span><span class="n">host</span><span class="si">}</span><span class="s2">/sitemap.xml"</span>

</code></pre></div> <p>Pour générer le sitemap, il suffit, en console, de lancer la commande suivante :</p> <div class=highlight><pre class="highlight console"><code><span class="gp">$</span> rake sitemap:generate
</code></pre></div> <p>Ou d&#39;utiliser <a href="http://www.antoine-brisset.com/blog/cron-job-whenever/">la gem Whenever</a> dont j&#39;ai déjà parlé pour créer une tâche cron qui sera chargée de rafraîchir le sitemap toutes les nuits par exemple. Il est également possible de paramétrer pas mal d&#39;options via un initializer, mais je vous laisse consulter <a href="https://github.com/lassebunk/dynamic_sitemaps/blob/master/README.md">la doc</a> pour plus de détails.</p> <h3>2ème option : utiliser la librairie Builder::XmlMarkup</h3> <p>Parfois, néanmoins, il n&#39;est pas possible d&#39;utiliser ce type de gem, notamment lorsqu&#39;on utilise un service de cloud comme <a href="https://www.heroku.com/">Heroku</a>, qui n&#39;autorise pas l&#39;écriture de fichiers. La solution est alors à chercher du côté de la librairie XML builder, qui met à notre disposition un ensemble de méthodes dédiées à la création d&#39;un fichier xml.</p> <p>Avant de construire notre fichier, il faut bien entendu mettre à jour le fichier <code>routes.rb</code> et lui indiquer à quel controller transmettre la requête. Et si nous utilisions notre controller <code>PagesController</code> ? Si vous vous souvenez du 1er article, nous l&#39;avions utilisé pour le fichier robots.txt.</p> <div class=highlight><pre class="highlight ruby"><code><span class="n">get</span> <span class="s1">'/sitemap.xml'</span> <span class="o">=&gt;</span> <span class="s1">'pages#sitemap'</span><span class="p">,</span> <span class="ss">defaults: </span><span class="p">{</span> <span class="ss">format: </span><span class="s1">'xml'</span> <span class="p">}</span>
</code></pre></div> <p>Dans le controller, nous allons définir les variables qui nous intéressent pour la construction du fichier sitemap. Reprenons l&#39;exemple de notre application et de son modèle <code>Article</code> : dans notre méthode sitemap, nous créons une variable d&#39;instance contenant l&#39;ensemble des articles publiés et nous précisons que la réponse doit être au format xml :</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">PagesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">sitemap</span>
    <span class="vi">@articles</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">published</span>
    <span class="n">respond_to</span> <span class="k">do</span> <span class="o">|</span><span class="nb">format</span><span class="o">|</span>
      <span class="nb">format</span><span class="p">.</span><span class="nf">xml</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span>
</code></pre></div> <p>Au niveau de la vue (dans views &gt; pages &gt; sitemap.xml.builder), il n&#39;y a plus qu&#39;à ajouter le prologue XML via <code>xml.instruct!</code>, d&#39;ajouter la balise d&#39;ouverture urlset via <code>xml.urlset</code> puis de boucler sur chacun des records.</p> <div class=highlight><pre class="highlight ruby"><code><span class="n">xml</span><span class="p">.</span><span class="nf">instruct!</span>
<span class="n">xml</span><span class="p">.</span><span class="nf">urlset</span><span class="p">(</span>
  <span class="s1">'xmlns'</span><span class="p">.</span><span class="nf">to_sym</span> <span class="o">=&gt;</span> <span class="s2">"http://www.sitemaps.org/schemas/sitemap/0.9"</span><span class="p">,</span>
<span class="p">)</span> <span class="k">do</span>
  <span class="vi">@articles</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">foodtruck</span><span class="o">|</span>
    <span class="n">xml</span><span class="p">.</span><span class="nf">url</span> <span class="k">do</span>
      <span class="n">xml</span><span class="p">.</span><span class="nf">loc</span> <span class="s2">"</span><span class="si">#{</span><span class="n">article_url</span><span class="p">(</span><span class="n">article</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
      <span class="n">xml</span><span class="p">.</span><span class="nf">lastmod</span> <span class="n">article</span><span class="p">.</span><span class="nf">updated_at</span><span class="p">.</span><span class="nf">strftime</span><span class="p">(</span><span class="s2">"%F"</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div> <p>Seul bémol : la page étant servie dynamiquement, le temps de chargement sera plus long lorsque Google viendra la consulter que si elle avait été générée en amont.</p> <h2>Définir une page d&#39;erreur 404</h2> <p>La page 404 est souvent la grande oubliée des projets de création ou de refonte de site. Elle est pourtant <a href="https://support.google.com/webmasters/answer/93641?hl=fr">recommandée par Google</a>. A ce titre, mais aussi et surtout pour des questions d&#39;expérience utilisateur, il est nécessaire de pouvoir en proposer une sur son site.</p> <p>Par défaut, Rails propose une page 404.html et une page 500.html qui se trouvent dans le dossier <code>public</code>, mais il s&#39;agit de pages statiques qui ne reprennent pas le layout de notre application. On peut donc faire mieux, en optant pour quelque chose de dynamique.</p> <p>Il est en effet possible au niveau de l&#39;applicatif de définir une page 404 personnalisée. Encore une fois, la première étape consiste à modifier le fichier <code>routes.rb</code> afin de lui indiquer ce qu&#39;il doit afficher en cas de page non trouvée. Créons un nouveau controller, pour ne pas surcharger le controller <code>PagesController</code>. Celui-ci s&#39;appellera par exemple <code>ErrorsController</code>.</p> <p>Par défaut, Rails s&#39;attend à ce que la page d&#39;erreur soit servie depuis la page /404. C&#39;est donc celle-ci que nous allons cibler dans le fichier <code>routes.rb</code> :</p> <div class=highlight><pre class="highlight ruby"><code><span class="n">get</span> <span class="s1">'/404'</span> <span class="o">=&gt;</span> <span class="s1">'errors#not_found'</span>
</code></pre></div> <p>Dans notre controller, ajoutons une méthode <code>not_found</code> qui se chargera d&#39;envoyer le bon code retour :</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">ErrorsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">not_found</span>
    <span class="n">render</span><span class="p">(</span><span class="ss">:status</span> <span class="o">=&gt;</span> <span class="mi">404</span><span class="p">)</span>
  <span class="k">end</span>

<span class="k">end</span>
</code></pre></div> <p><u>Les trois étapes restantes sont alors</u> :</p> <ul> <li>de modifier la page <code>not_found.html.slim</code> (si vous utilisez slim) afin d&#39;afficher un message personnalisé qui reprendra le layout principal</li> <li>de supprimer la page 404.html dans le dossier <code>public</code></li> <li>de demander à Rails d&#39;utiliser les routes que nous avons déclarées plutôt que celles utilisées par défaut</li> </ul> <div class=highlight><pre class="highlight ruby"><code><span class="n">config</span><span class="p">.</span><span class="nf">exceptions_app</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">routes</span>
</code></pre></div> <p>Et voilà, il n&#39;y a plus qu&#39;à tester ! Bien entendu, vous pouvez vous inspirer de la méthodologie ci-dessus pour la gestion des erreurs 410, ou encore des erreurs 503. A noter, enfin, que si votre applicatif génère une erreur 500, peu importe l&#39;URL demandée, il ne pourra pas exécuter les actions définies dans votre controller <code>ErrorsController</code>. Il n&#39;est donc pas inutile de configurer votre serveur de manière à ce qu&#39;il prenne le relais quand Rails est incapable de traiter une requête.</p> <h2>Booster le temps de chargement avec Last-Modified</h2> <p>Petit bonus : si vous souhaitez améliorer vos temps de réponse et ainsi augmenter le nombre de pages crawlées par Google à l&#39;intérieur d&#39;une même fenêtre de crawl, voici comment gérer facilement vos requêtes HTTP conditionnelles pour renvoyer un maximum de codes 304 Not Modified. Car, oui, <a href="https://support.google.com/webmasters/answer/35769?hl=fr">Google utilise l&#39;en-tête HTTP If-Modified-Since</a> dans ses requêtes et il serait dommage de ne pas en tirer profit.</p> <p>Reprenons l&#39;exemple de notre blog et du modèle <code>Article</code>. Nous allons utiliser la méthode <code>fresh_when</code> suivie de l&#39;argument <code>last_modified</code> dont la valeur correspondra à la date de dernière mise à jour de l&#39;objet (<code>updated_at</code>), ce qui donne :</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">show</span>
  <span class="vi">@article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">friendly</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">])</span>
  <span class="n">fresh_when</span> <span class="ss">last_modified: </span><span class="vi">@article</span><span class="p">.</span><span class="nf">updated_at</span>
<span class="k">end</span>
</code></pre></div> <p>Automatiquement, cette méthode va fixer la valeur de l&#39;en-tête <code>Last-Modified</code> et déterminer, pour chaque requête vers une page article, si un code 304 Not Modified doit être renvoyé : si la date de dernière modification de l&#39;objet est inférieure à la date stipulée dans le <code>If-Modified-Since</code>, la requête est &ldquo;fresh&rdquo; (on renvoie un code 304 avec une réponse partielle), sinon elle est &ldquo;stale&rdquo; (on renvoie un code 200 avec la réponse complète).</p> <p>Pour vérifier la bonne implémentation de la 304, vous pouvez utiliser cURL en ligne de commande (changez la date et l&#39;URL en fonction de ce que vous voulez tester):</p> <div class=highlight><pre class="highlight console"><code><span class="go">curl -I -H "If-Modified-Since: Thu, 20 Jul 2016 21:00:00 GMT" http://www.antoine-brisset.com
</span></code></pre></div> <p>J&#39;espère que ces deux articles sur l&#39;optimisation SEO de votre application Ruby on Rails vous auront plu. N&#39;hésitez pas si vous avez des questions ou si vous souhaitez que je creuse un sujet en particulier.</p> <div id=disqus_thread></div> <script>
//<![CDATA[
                  var disqus_shortname = 'blogantoinebrisset';
          
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
//]]>
</script> <noscript>Please enable JavaScript to view the <a href='http://disqus.com/?ref_noscript'>comments powered by Disqus.</a></noscript> <a href='http://disqus.com' class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a> </article></div></div><footer class=footer><div role=content-info><ul class=footer__content><li class=footer__content__item><i class="fa fa-home"></i> Marquette-lez-Lille</li><li class=footer__content__item><i class="fa fa-phone"></i> 06 12 71 82 78</li><li class=footer__content__item><i class="fa fa-envelope"></i> <a href="#email-protection-pbagnpg@nagbvar-oevffrg.pbz">contact@antoine-brisset.com</a> </li></ul><ul class=footer__content--social><li class=footer__content__item--social><a href="https://twitter.com/abrisset"><i class='fa fa-twitter footer__icon'></i></a></li><li class=footer__content__item--social><a href="https://github.com/ABrisset"><i class='fa fa-github footer__icon'></i></a></li><li class=footer__content__item--social><a href="http://plus.google.com/112811217796192792405?rel=author"><i class='fa fa-google-plus footer__icon'></i></a></li></ul><div class=footer__copyright> &copy; 2019 - <a href="/">Antoine Brisset</a></div></div></footer><script type="text/javascript">!function(){try{var a,b,c,d,g=document.getElementsByTagName("a");for(c=0;g.length-c;c++)try{b=g[c].getAttribute("href"),b&&b.indexOf("#email-protection-")>-1&&b.length>19&&(a="",d=19+b.indexOf("#email-protection-"),b.length>d&&(a=b.substr(18).replace(/[a-zA-Z]/g,function(a){return String.fromCharCode(("Z">=a?90:122)>=(a=a.charCodeAt(0)+13)?a:a-26)})),g[c].setAttribute("href","mailto:"+a))}catch(h){}}catch(h){}}();</script>
</body></html>