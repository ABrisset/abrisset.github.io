<!DOCTYPE html><html lang=fr><head><meta charset=utf-8 /><meta content="width=device-width,initial-scale=1" name=viewport /><title>Comparer deux sets d'URLs avec Ruby &bull; Antoine Brisset</title><meta content="Un exemple de script Ruby pour rendre plus facile la mise en place de redirections SEO lors d'une migration, à travers la comparaison des slugs d'URLs." name=description /><meta content="index,follow" name=robots /><meta content=R7aPiADkUTnBNzbTvsqutfN3_gewIxUFwJpKYyc-hBQ name=google-site-verification /><link href="/apple-touch-icon.png" rel=apple-touch-icon sizes=57x57 /><link href="/apple-touch-icon-57x57-precomposed.png" rel=apple-touch-icon sizes=57x57 /><link href="/apple-touch-icon-60x60-precomposed.png" rel=apple-touch-icon sizes=60x60 /><link href="/apple-touch-icon-72x72-precomposed.png" rel=apple-touch-icon sizes=72x72 /><link href="/apple-touch-icon-76x76-precomposed.png" rel=apple-touch-icon sizes=76x76 /><link href="/apple-touch-icon-114x114-precomposed.png" rel=apple-touch-icon sizes=114x114 /><link href="/apple-touch-icon-120x120-precomposed.png" rel=apple-touch-icon sizes=120x120 /><link href="/apple-touch-icon-144x144-precomposed.png" rel=apple-touch-icon sizes=144x144 /><link href="/apple-touch-icon-152x152-precomposed.png" rel=apple-touch-icon sizes=152x152 /><link href="/favicon-196x196.png" rel=icon sizes=196x196 type="image/png"/><link href="/favicon-160x160.png" rel=icon sizes=160x160 type="image/png"/><link href="/favicon-96x96.png" rel=icon sizes=96x96 type="image/png"/><link href="/favicon-32x32.png" rel=icon sizes=32x32 type="image/png"/><link href="/favicon-16x16.png" rel=icon sizes=16x16 type="image/png"/><meta content="#f5f5f5" name=msapplication-TileColor /><meta content="/mstile-144x144.png" name=msapplication-TileImage /><link href="/stylesheets/application.css" rel=stylesheet /><link href="//fonts.googleapis.com/css?family=Open+Sans:400,300,600,700,800" rel=stylesheet /><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel=stylesheet /><style>.header{background-image: url('/images/backgrounds/small/code.jpeg');}
    @media screen and (min-width: 25em){.header{background-image: url('/images/backgrounds/medium/code.jpeg');}}
    @media screen and (min-width: 50em){.header{background-image: url('/images/backgrounds/code.jpeg');}}</style><script src="/javascripts/all.js"></script></head><body class="blog blog_comparer-deux-sets-durls-avec-ruby blog_comparer-deux-sets-durls-avec-ruby_index"> <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-WW7MSH" height=0 width=0 style="display:none;visibility:hidden"></iframe></noscript> <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-NKG6T7');</script> <div class=wrapper><nav role=navigation><div class=fat-nav><div class=fat-nav__wrapper><ul><li><a href="/">Accueil</a></li><li><a href="/blog/">Blog SEO</a></li><li><a href="/#contact">Contact</a></li></ul></div></div></nav></div><div role=main></div><div class=header><div class=wrapper><h1 class=header__title>Comparer deux sets d'URLs avec Ruby</h1><p class=header__category><i class="fa fa-tag"></i> <em>Scripts SEO</em></p></div></div><div class="section section__content--large"><div class=wrapper><article class=blog__article><p class=blog__breadcrumb><a href="/blog/">Blog SEO</a> / <a href="/blog/categories/scripts-seo/">Scripts SEO</a></p><p class=blog__date>Publié le 11 Aug 2013</p><p class=blog__chapo>Dans le cadre d'une refonte, souvent, les URLs d'un site sont modifiées et générées selon de nouvelles règles : ajout de répertoires, modification du séparateur d'URL, renommage de catégories, etc. Cela oblige donc à créer tout un paquet de redirections, afin d'assurer une transition correcte en termes de PR, d'indexation et de trafic moteur. Je vous propose ici un petit script Ruby, qui vous permettra de préparer le terrain en matchant vos anciennes URLs avec les nouvelles...</p><h2>Préparer les deux jeux d&#39;URLs</h2> <p>Dans un premier temps, il faut collecter toutes les URLs existantes. Pour faire cela, plusieurs méthodes complémentaires : crawl du site, scraping des pages indexées par Google, export des landing pages les plus stratégiques via Google Analytics, etc. Regroupez toutes ces URLs dans un fichier, dédoublonnez, et sauvegardez en CSV.</p> <p>En parallèle, crawlez le nouveau site, avec votre outil homemade ou une solution comme Screaming Frog, et exportez toute les URLs dans un deuxième fichier. Glissez les deux fichiers dans un répertoire commun. Vous voilà prêt pour la suite.</p> <h2>Place au script</h2> <p>L&#39;objectif du script est de décomposer chaque URL du premier fichier (anciennes URL), en ne conservant que le slug, puis de comparer chaque slug à chaque URL du deuxième fichier, afin de déterminer quelles sont les URLs du nouveau site qui contiennent des caractères communs avec chacun de ces slugs.</p> <h3>Première étape : extraire les URLs du CSV et les placer dans un array</h3> <p>Pour commencer, il faut faire appel aux gems CSV et URI qui vous permettront de manipuler les fichiers CSV ainsi que les URLs comme vous le souhaitez.</p> <div class=highlight><pre class="highlight ruby"><code><span class="c1">#!/usr/bin/env ruby</span>

<span class="nb">require</span> <span class="s1">'csv'</span>
<span class="nb">require</span> <span class="s1">'uri'</span>
</code></pre></div> <p>Ensuite, il faut extraire chaque URL des fichiers CSV et les placer dans un array. Pour cela, on utilise la méthode &ldquo;reduce&rdquo; dont j&#39;ai déjà parlé dans un article sur le <a href="http://www.antoine-brisset.com/blog/ruby-scraping/">scraping</a>.</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">select_first_array_elem</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">array</span><span class="p">.</span><span class="nf">reduce</span><span class="p">([])</span> <span class="k">do</span> <span class="o">|</span><span class="n">result</span><span class="p">,</span> <span class="n">elem</span><span class="o">|</span>
        <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="nf">first</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div> <h3>Deuxième étape : réduire chaque URL à son slug</h3> <p>Pour cela, nous allons définir une fonction utilisant &ldquo;split&rdquo;. Cette méthode permet de découper une string sur la base d&#39;un délimiteur spécifique. Dans le cas d&#39;une URL, le délimiteur choisi sera donc le &ldquo;/&rdquo;. En sortie, un array sera généré avec chacun des éléments. Dans notre cas, c&#39;est uniquement la dernière partie de l&#39;URL, le slug, qui nous intéresse. Nous allons donc sélectionner ce dernier élément de l&#39;array avec un &ldquo;.last&rdquo;.</p> <p>Pour rendre plus propres les URLs, nous allons ensuite utiliser la méthode &ldquo;slice!&rdquo; qui permet, à partir d&#39;une string, de retourner une nouvelle string, dont on a supprimé certains caractères. Ici, on utilise comme argument une regexp qui matche toutes les extensions possibles : html, gif, png, jpg, etc.</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">split_url</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">url</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">'/'</span><span class="p">).</span><span class="nf">last</span>
    <span class="n">result</span><span class="p">.</span><span class="nf">slice!</span><span class="p">(</span><span class="sr">/.html|.gif|.jpg|.png/</span><span class="p">)</span>
    <span class="n">result</span>
<span class="k">end</span>
</code></pre></div> <h3>Troisième étape : comparer chaque slug avec les nouvelles URLs</h3> <p>Dans cette partie, nous allons définir une fonction permettant, concrètement :</p> <ul> <li>de prendre le slug de chaque URL du premier fichier</li> <li>de le comparer à chaque URL du deuxième fichier</li> <li>de créer un tableau avec l&#39;URL du 1er fichier et la (ou les) correspondance(s) trouvée(s) dans le 2ème fichier</li> </ul> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">included_in</span><span class="p">(</span><span class="n">array_1</span><span class="p">,</span><span class="n">array_2</span><span class="p">)</span>
    <span class="c1"># on initialise le tableau de sortie</span>
  <span class="n">results</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># on décompose chaque URL du fichier contenant les anciennes URLs</span>
    <span class="n">array_1</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">old_url</span><span class="o">|</span>
        <span class="c1"># on crée une variable avec l'host de de l'url</span>
        <span class="n">host</span> <span class="o">=</span> <span class="no">URI</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">old_url</span><span class="p">).</span><span class="nf">host</span>
        <span class="c1"># on extrait le slug de l'URL</span>
        <span class="n">slug</span> <span class="o">=</span> <span class="n">split_url</span><span class="p">(</span><span class="n">old_url</span><span class="p">)</span>
        <span class="c1"># on vérifie que l'URL n'est pas égale à la racine</span>
        <span class="k">if</span> <span class="n">old_url</span> <span class="o">!=</span> <span class="s2">"http://</span><span class="si">#{</span><span class="n">host</span><span class="si">}</span><span class="s2">"</span>
            <span class="c1"># on vérifie que le slug fait plus de 1 caractère</span>
            <span class="k">if</span> <span class="n">slug</span><span class="p">.</span><span class="nf">length</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="c1"># on boucle sur chaque URL du fichier contenant les nouvelles URLs</span>
                <span class="n">array_2</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">new_url</span><span class="o">|</span>
                    <span class="c1"># on crée de nouvelles variables uniquement si les nouvelles URLs "contiennent" la variable "slug"</span>
                    <span class="k">if</span> <span class="n">new_url</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">slug</span><span class="p">)</span>
                        <span class="n">url_from</span>    <span class="o">=</span> <span class="n">old_url</span>
                        <span class="n">status</span>      <span class="o">=</span> <span class="s2">"matches"</span>
                        <span class="n">url_to</span>      <span class="o">=</span> <span class="n">new_url</span>
                    <span class="k">end</span>
                    <span class="c1"># on remplit le tableau avec ces variables</span>
                    <span class="n">results</span> <span class="o">&lt;&lt;</span> <span class="p">[</span><span class="n">url_from</span><span class="p">,</span><span class="n">status</span><span class="p">,</span><span class="n">url_to</span><span class="p">]</span>
                <span class="k">end</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
  <span class="c1"># on retourne le tableau dédoublonné</span>
    <span class="n">results</span><span class="p">.</span><span class="nf">uniq</span>
<span class="k">end</span>
</code></pre></div> <p>Comme vous le voyez, j&#39;utilise ici une méthode très pratique, <a href="http://ruby-doc.org/core-2.0/Array.html#method-i-include-3F">include?</a> qui permet de vérifier si un objet passé en argument est présent dans l&#39;objet sur lequel on effectue le test.</p> <h3>Quatrième étape : exporter les résultats dans un fichier CSV</h3> <p>Pour terminer, on construit un fichier CSV. Pour cela, nous allons donc utiliser la méthode CSV. Chaque ligne du tableau contiendra l&#39;URL source, la mention &ldquo;matches&rdquo; et l&#39;URL vers laquelle rediriger.</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">write_data_to_csv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
  <span class="no">CSV</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">"wb"</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">csv</span><span class="o">|</span>
    <span class="n">csv</span> <span class="o">&lt;&lt;</span> <span class="p">[</span><span class="s2">"URL From"</span><span class="p">,</span> <span class="s2">"Status"</span><span class="p">,</span> <span class="s2">"URL To Redirect"</span><span class="p">]</span>
    <span class="n">data</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span>
        <span class="n">csv</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div> <p>Il ne reste plus qu&#39;à déclarer le chemin des fichiers et à utiliser nos différentes fonctions.</p> <div class=highlight><pre class="highlight ruby"><code><span class="c1"># chemin vers le fichier de résultats</span>
<span class="n">file_path</span>       <span class="o">=</span> <span class="s2">"./results.csv"</span>

<span class="c1"># création d'un array avec les fichiers d'entrées (anciennes URLs, nouvelles URLs)</span>
<span class="n">arr_of_arrs</span>     <span class="o">=</span> <span class="no">CSV</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="s2">"./array_1.csv"</span><span class="p">)</span>
<span class="n">arr_of_arrs_2</span>   <span class="o">=</span> <span class="no">CSV</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="s2">"./array_2.csv"</span><span class="p">)</span>

<span class="c1"># sélection de la première colonne de chaque fichier d'entrée (URLs)</span>
<span class="n">array_1</span>             <span class="o">=</span> <span class="n">select_first_array_elem</span><span class="p">(</span><span class="n">arr_of_arrs</span><span class="p">)</span>
<span class="n">array_2</span>             <span class="o">=</span> <span class="n">select_first_array_elem</span><span class="p">(</span><span class="n">arr_of_arrs_2</span><span class="p">)</span>

<span class="c1"># création d'un array sur la base des slugs du fichier array_1 retrouvés dans array_2</span>
<span class="n">union</span>               <span class="o">=</span> <span class="n">included_in</span><span class="p">(</span><span class="n">array_1</span><span class="p">.</span><span class="nf">uniq</span><span class="p">,</span><span class="n">array_2</span><span class="p">.</span><span class="nf">uniq</span><span class="p">)</span>

<span class="c1"># export en CSV</span>
<span class="n">write_data_to_csv</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">union</span><span class="p">)</span>
</code></pre></div> <p>Et voilà, si vous êtes sous Apache, vous n&#39;avez plus qu&#39;à faire un rechercher/remplacer avec &ldquo;RewriteRule&rdquo; et les flags 301 qui vont bien :)</p> <div id=disqus_thread></div> <script>
//<![CDATA[
                  var disqus_shortname = 'blogantoinebrisset';
          
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
//]]>
</script> <noscript>Please enable JavaScript to view the <a href='http://disqus.com/?ref_noscript'>comments powered by Disqus.</a></noscript> <a href='http://disqus.com' class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a> </article></div></div><footer class=footer><div role=content-info><ul class=footer__content><li class=footer__content__item><i class="fa fa-home"></i> Marquette-lez-Lille</li><li class=footer__content__item><i class="fa fa-phone"></i> 06 12 71 82 78</li><li class=footer__content__item><i class="fa fa-envelope"></i> <a href="#email-protection-pbagnpg@nagbvar-oevffrg.pbz">contact@antoine-brisset.com</a> </li></ul><ul class=footer__content--social><li class=footer__content__item--social><a href="https://twitter.com/abrisset"><i class='fa fa-twitter footer__icon'></i></a></li><li class=footer__content__item--social><a href="https://github.com/ABrisset"><i class='fa fa-github footer__icon'></i></a></li><li class=footer__content__item--social><a href="http://plus.google.com/112811217796192792405?rel=author"><i class='fa fa-google-plus footer__icon'></i></a></li></ul><div class=footer__copyright> &copy; 2019 - <a href="/">Antoine Brisset</a></div></div></footer><script type="text/javascript">!function(){try{var a,b,c,d,g=document.getElementsByTagName("a");for(c=0;g.length-c;c++)try{b=g[c].getAttribute("href"),b&&b.indexOf("#email-protection-")>-1&&b.length>19&&(a="",d=19+b.indexOf("#email-protection-"),b.length>d&&(a=b.substr(18).replace(/[a-zA-Z]/g,function(a){return String.fromCharCode(("Z">=a?90:122)>=(a=a.charCodeAt(0)+13)?a:a-26)})),g[c].setAttribute("href","mailto:"+a))}catch(h){}}catch(h){}}();</script>
</body></html>