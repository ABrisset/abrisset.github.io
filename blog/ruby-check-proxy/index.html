<!DOCTYPE html><html lang=fr><head><meta charset=utf-8 /><meta content="width=device-width,initial-scale=1" name=viewport /><title>Tester un proyx avec Ruby &bull; Antoine Brisset</title><meta content="Vous avez besoin de savoir si vos proxies sont valides Google ? Testez les avec ce script Ruby." name=description /><meta content="index,follow" name=robots /><meta content=R7aPiADkUTnBNzbTvsqutfN3_gewIxUFwJpKYyc-hBQ name=google-site-verification /><link href="/apple-touch-icon.png" rel=apple-touch-icon sizes=57x57 /><link href="/apple-touch-icon-57x57-precomposed.png" rel=apple-touch-icon sizes=57x57 /><link href="/apple-touch-icon-60x60-precomposed.png" rel=apple-touch-icon sizes=60x60 /><link href="/apple-touch-icon-72x72-precomposed.png" rel=apple-touch-icon sizes=72x72 /><link href="/apple-touch-icon-76x76-precomposed.png" rel=apple-touch-icon sizes=76x76 /><link href="/apple-touch-icon-114x114-precomposed.png" rel=apple-touch-icon sizes=114x114 /><link href="/apple-touch-icon-120x120-precomposed.png" rel=apple-touch-icon sizes=120x120 /><link href="/apple-touch-icon-144x144-precomposed.png" rel=apple-touch-icon sizes=144x144 /><link href="/apple-touch-icon-152x152-precomposed.png" rel=apple-touch-icon sizes=152x152 /><link href="/favicon-196x196.png" rel=icon sizes=196x196 type="image/png"/><link href="/favicon-160x160.png" rel=icon sizes=160x160 type="image/png"/><link href="/favicon-96x96.png" rel=icon sizes=96x96 type="image/png"/><link href="/favicon-32x32.png" rel=icon sizes=32x32 type="image/png"/><link href="/favicon-16x16.png" rel=icon sizes=16x16 type="image/png"/><meta content="#f5f5f5" name=msapplication-TileColor /><meta content="/mstile-144x144.png" name=msapplication-TileImage /><link href="/stylesheets/application.css" rel=stylesheet /><link href="//fonts.googleapis.com/css?family=Open+Sans:400,300,600,700,800" rel=stylesheet /><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel=stylesheet /><style>.header{background-image: url('/images/backgrounds/small/code.jpeg');}
    @media screen and (min-width: 25em){.header{background-image: url('/images/backgrounds/medium/code.jpeg');}}
    @media screen and (min-width: 50em){.header{background-image: url('/images/backgrounds/code.jpeg');}}</style><script src="/javascripts/all.js"></script></head><body class="blog blog_ruby-check-proxy blog_ruby-check-proxy_index"> <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-WW7MSH" height=0 width=0 style="display:none;visibility:hidden"></iframe></noscript> <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-NKG6T7');</script> <div class=wrapper><nav role=navigation><div class=fat-nav><div class=fat-nav__wrapper><ul><li><a href="/">Accueil</a></li><li><a href="/blog/">Blog SEO</a></li><li><a href="/#contact">Contact</a></li></ul></div></div></nav></div><div role=main></div><div class=header><div class=wrapper><h1 class=header__title>Tester la validité d'un proxy avec Ruby</h1><p class=header__category><i class="fa fa-tag"></i> <em>Scripts SEO</em></p></div></div><div class="section section__content--large"><div class=wrapper><article class=blog__article><p class=blog__breadcrumb><a href="/blog/">Blog SEO</a> / <a href="/blog/categories/scripts-seo/">Scripts SEO</a></p><p class=blog__date>Publié le 18 Aug 2013</p><p class=blog__chapo>Pour ne pas se faire refouler par Google quand on lui envoie trop de requêtes en automatique, il est important de se munir de proxies. Mais encore faut-il qu'ils soient valides ! Qu'ils soient <a href='https://www.google.fr/search?q=fresh+proxies&amp;tbs=qdr:h'>publics</a> ou privés, l'important, c'est donc de pouvoir tester leur validité avant d'entamer toute action de scraping.</p><p>Je vous propose donc un nouveau petit script Ruby, qui à partir, d&#39;un array de proxies, vérifie s&#39;ils sont valides Google ou non. Ce script utilise la librairie <a href="http://ruby-doc.org/stdlib-2.0/libdoc/net/http/rdoc/Net/HTTP.html">Net::HTTP</a>, pensez donc à ajouter ceci en début de fichier.</p> <div class=highlight><pre class="highlight ruby"><code><span class="c1">#!/usr/bin/env ruby</span>

<span class="nb">require</span> <span class="s1">'net/http'</span>
</code></pre></div> <p>Commencez par définir une variable contenant vos proxies. Par exemple :</p> <div class=highlight><pre class="highlight ruby"><code><span class="n">proxies</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"1.179.147.2:8080"</span><span class="p">,</span><span class="s2">"1.93.21.147:2222"</span><span class="p">,</span><span class="s2">"100.45.50.131:8080"</span><span class="p">,</span><span class="s2">"101.109.251.140:80"</span><span class="p">,</span><span class="s2">"101.109.251.140:8080"</span><span class="p">]</span>
</code></pre></div> <p>Voici ensuite la méthode utilisée (que j&#39;ai nommée connectable), commentée pas à pas :</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">connectable</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="c1"># on crée un array vide qui nous servira à collecter les proxies valides</span>
  <span class="n">results</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="c1"># on définit un block à partir de l'array</span>
  <span class="n">array</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">proxy</span><span class="o">|</span>
    <span class="c1"># on découpe le proxy avec ":"</span>
    <span class="c1"># on crée ainsi les variables host et port à partir des deux éléments</span>
    <span class="n">host</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">proxy</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">':'</span><span class="p">)</span>
    <span class="c1"># on démarre un block begin/end</span>
    <span class="k">begin</span>
        <span class="c1"># on crée un nouvel objet HTTP utilisant les paramètres du proxy</span>
        <span class="c1"># la session n'est pas encore ouverte</span>
      <span class="n">http</span>              <span class="o">=</span> <span class="no">Net</span><span class="o">::</span><span class="no">HTTP</span><span class="o">::</span><span class="no">Proxy</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">).</span><span class="nf">new</span><span class="p">(</span><span class="s1">'www.google.fr'</span><span class="p">)</span>
      <span class="c1"># on définit un timeout de 0,5 secondes pour la connexion</span>
      <span class="n">http</span><span class="p">.</span><span class="nf">open_timeout</span> <span class="o">=</span> <span class="mf">0.5</span>
      <span class="c1"># on définit un timeout de 0,5 secondes pour le chargement</span>
      <span class="n">http</span><span class="p">.</span><span class="nf">read_timeout</span> <span class="o">=</span> <span class="mf">0.5</span>
      <span class="c1"># on ouvre la session avec la méthode start</span>
      <span class="n">http</span><span class="p">.</span><span class="nf">start</span> <span class="k">do</span> <span class="o">|</span><span class="n">connect</span><span class="o">|</span>
        <span class="c1"># on récupère la réponse HTTP d'une requête "site:example.com" sur Google</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">connect</span><span class="p">.</span><span class="nf">head</span><span class="p">(</span><span class="s1">'/search?safe=off&amp;hl=fr&amp;q=site:example.com'</span><span class="p">)</span>
        <span class="c1"># on définit un comportement spécifique en fonction de la réponse</span>
        <span class="k">case</span> <span class="n">response</span>
        <span class="c1"># si le code retour apartient à la classe Net::HTTPOK (code 200)</span>
        <span class="k">when</span> <span class="no">Net</span><span class="o">::</span><span class="no">HTTPOK</span>
            <span class="c1"># on stocke le proxy utilisé dans l'array results</span>
          <span class="n">results</span> <span class="o">&lt;&lt;</span> <span class="n">proxy</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">rescue</span>
        <span class="c1"># si la connexion est impossible, on retourne nil</span>
      <span class="kp">nil</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="c1"># on affiche les proxies valides dans la console</span>
  <span class="nb">puts</span> <span class="n">results</span>
<span class="k">end</span>
</code></pre></div> <p>Concrètement, l&#39;objectif est d&#39;ouvrir une connexion sur www.google.fr, en passant à travers chaque proxy de l&#39;array, puis d&#39;effectuer une requête assez &ldquo;sensible&rdquo; en utilisant la commande &ldquo;site:&rdquo;. Si le code réponse renvoyé par Google est 200, le proxy est considéré valide donc on le stocke, sinon on passe au suivant.</p> <p>Libre à vous de jouer sur les temps de timeout en fonction de votre tolérance aux performances des proxies. Pour améliorer ce script, vous pouvez également exporter le tout dans un fichier CSV.</p> <p>Pour exécuter la méthode, ajoutez simplement à la fin de votre fichier .rb :</p> <div class=highlight><pre class="highlight ruby"><code><span class="n">connectable</span><span class="p">(</span><span class="n">proxies</span><span class="p">)</span>
</code></pre></div> <p>A vous de jouer !</p> <div id=disqus_thread></div> <script>
//<![CDATA[
                  var disqus_shortname = 'blogantoinebrisset';
          
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
//]]>
</script> <noscript>Please enable JavaScript to view the <a href='http://disqus.com/?ref_noscript'>comments powered by Disqus.</a></noscript> <a href='http://disqus.com' class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a> </article></div></div><footer class=footer><div role=content-info><ul class=footer__content><li class=footer__content__item><i class="fa fa-home"></i> Marquette-lez-Lille</li><li class=footer__content__item><i class="fa fa-phone"></i> 06 12 71 82 78</li><li class=footer__content__item><i class="fa fa-envelope"></i> <a href="#email-protection-pbagnpg@nagbvar-oevffrg.pbz">contact@antoine-brisset.com</a> </li></ul><ul class=footer__content--social><li class=footer__content__item--social><a href="https://twitter.com/abrisset"><i class='fa fa-twitter footer__icon'></i></a></li><li class=footer__content__item--social><a href="https://github.com/ABrisset"><i class='fa fa-github footer__icon'></i></a></li><li class=footer__content__item--social><a href="http://plus.google.com/112811217796192792405?rel=author"><i class='fa fa-google-plus footer__icon'></i></a></li></ul><div class=footer__copyright> &copy; 2019 - <a href="/">Antoine Brisset</a></div></div></footer><script type="text/javascript">!function(){try{var a,b,c,d,g=document.getElementsByTagName("a");for(c=0;g.length-c;c++)try{b=g[c].getAttribute("href"),b&&b.indexOf("#email-protection-")>-1&&b.length>19&&(a="",d=19+b.indexOf("#email-protection-"),b.length>d&&(a=b.substr(18).replace(/[a-zA-Z]/g,function(a){return String.fromCharCode(("Z">=a?90:122)>=(a=a.charCodeAt(0)+13)?a:a-26)})),g[c].setAttribute("href","mailto:"+a))}catch(h){}}catch(h){}}();</script>
</body></html>